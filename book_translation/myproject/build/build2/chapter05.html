<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Introducción a p5.js</title>
    <script src="assets/p5.js"></script>
<script src="assets/scripts.js"></script>

    <link rel="stylesheet" href="assets/html.css">

  </head>
  <body data-type="book">
    <div class="container">
      <section data-type="chapter" id="capitulo_07_medios">

<h1>Cap&#xED;tulo 5. Respuesta</h1>

El c&#xF3;digo que responde a acciones de entrada del rat&#xF3;n, teclado u otros dispositivos  depende en que el programa corra continuamente. Ya nos enfrentamos a las funciones setup() y draw() en el Cap&#xED;tulo 1. Ahora aprenderemos m&#xE1;s sobre qu&#xE9; hacen y c&#xF3;mo usarlas para reaccionar a entradas al programa.

## Una vez y para siempre

El c&#xF3;digo dentro del bloque draw() corre desde el principio al final, luego se repite hasta que cierras el programa cuando cierras la ventana. Cada iteraci&#xF3;n a trav&#xE9;s del bloque draw() es llamado un cuadro o frame. (La tasa de cuadros por defecto es de 60 cuadros por segundo, pero esto puede ser modificado).

## Ejemplo 5-1: la funci&#xF3;n draw()

Para observar como la funci&#xF3;n draw() funciona, corre este ejemplo:

```
function draw() {
  //Muestra en la consola el contador de cuadros
  print(&quot;Estoy dibujando&quot;);
  print(frameCount);
}
```
Ver&#xE1;s lo siguiente:

```
Estoy dibujando
1
Estoy dibujando
2
Estoy dibujando
3
...
```

En el ejemplo anterior, las funciones print() escriben el texto &quot;Estoy dibujando&quot; seguido del contador actual de cuadros, tarea efectuada por la variable especial frameCount. El texto aparece en la consola de tu navegador.

## Ejemplo 5-2: la funci&#xF3;n setup()

Para complementar la repetitiva funci&#xF3;n draw(), p5.js posee la funci&#xF3;n setup() que solo corre una vez cuando el programa empieza:

```
function setup() {
  print(&quot;Estoy empezando&quot;);
}

function draw() {
  print(&quot;Estoy corriendo&quot;);
}
```

Cuando corres el c&#xF3;digo, en la consola se escribe lo siguiente:

```
Estoy empezando
Estoy corriendo
Estoy corriendo
Estoy corriendo
...
```

El texto &quot;Estoy corriend&quot; sigue escribi&#xE9;ndose en la consola hasta que el programa es parado.

En algunos navegadores, en vez de escribir una y otra vez &quot;Estoy corriendo&quot;, lo imprimir&#xE1; solo una vez, y despu&#xE9;s para cada subsecuente vez, incrementar&#xE1; un n&#xFA;mero junto a la l&#xED;nea, representando el n&#xFA;mero total de veces que la l&#xED;nea ha sido impresa de corrido.

En un programa t&#xED;pico, el c&#xF3;digo dentro de setup() es usado para definir las condiciones iniciales. La primera l&#xED;nea es usualmente la funci&#xF3;n createCanvas(), a menudo seguida de c&#xF3;digo para definir los colores de relleno y trazado iniciales. (Si no incluyes la funci&#xF3;n createCanvas(), el lienzo para dibujar tendr&#xE1; una dimensi&#xF3;n de 100x100 pixeles por defecto).

Ahora sabes c&#xF3;mo usar setup() y draw() en mayor detalle, pero esto no es todo.

Hay una ubicaci&#xF3;n adicional d&#xF3;nde has estado poniendo c&#xF3;digo - tambi&#xE9;n puedes poner variables globales fuera de setup() y draw(). Esto se hace m&#xE1;s claro cuando listamos el orden en que el c&#xF3;digo es ejecutado.

1. Las variables declaradas fuera de setup() y draw() son creadas.

2. El c&#xF3;digo dentro de setup() es ejecutado una vez.

3. El c&#xF3;digo dentro de draw() corre continuamente.

## Ejemplo 5-3: setup(), te presento a draw()

El siguiente ejemplo pone en pr&#xE1;ctica todos estos conceptos:

```
var x = 280;
var y = -100;
var diameter = 380;

function setup() {
  createCanvas(480, 120);
  fill(102);
}

function draw() {
  background(204);
  ellipse(x, y, diameter, diameter);
}
```

## Seguir

Como el c&#xF3;digo est&#xE1; corriendo continuamente, podemos seguir la posici&#xF3;n del rat&#xF3;n y usar estos n&#xFA;meros para mover elementos en la pantalla.

## Ejemplo 5-4: seguir al rat&#xF3;n

La variable mouseX graba la coordenada x, y la variable mouseY graba la coordenada y:

```
function setup() {
  createCanvas(480, 120);
  fill(0, 102);
  noStroke();
}

function draw() {
  ellipse(mouseX, mouseY, 9, 9);
}
```
En este ejemplo, cada vez que el c&#xF3;digo en el bloque draw() es ejecutado, un nuevo c&#xED;rculo es a&#xF1;adido al lienzo. La imagen fue hecha moviendo el rat&#xF3;n para controlar la posici&#xF3;n del c&#xED;rculo. Como la funci&#xF3;n de relleno est&#xE1; definida para ser parcialmente transparente, las &#xE1;reas negras m&#xE1;s densas muestran d&#xF3;nde el rat&#xF3;n estuvo m&#xE1;s tiempo o se movi&#xF3; m&#xE1;s lento. Los c&#xED;rculos que est&#xE1;n m&#xE1;s separados muestran d&#xF3;nde el rat&#xF3;n estuvo movi&#xE9;ndose m&#xE1;s r&#xE1;pido.

## Ejemplo 5-5: el punto te persigue

En este ejemplo, un nuevo c&#xED;rculo es a&#xF1;adido al lienzo cada vez que el c&#xF3;digo dentro de draw() es ejecutado. Para refrescar la pantalla y sollo mostrar el c&#xED;rculo m&#xE1;s reciente, escribe la funci&#xF3;n background() al principio del bloque draw() antes que la figura sea dibujada:

```
function setup() {
  createCanvas(480, 120);
  fill(0, 102);
  noStroke();
}

function draw() {
  background(204);
  ellipse(mouseX, mouseY, 9, 9);
}
```
La funci&#xF3;n background() pinta el lienzo completo , as&#xED; que aseg&#xFA;rate de ponerlo antes que las otras funciones dentro de draw(). Si no haces esto, las figuras dibujadas antes ser&#xE1;n borradas.

## Ejemplo 5-6: dibuja de forma continua

Las variables pmouseX y pmouseY guardan la posici&#xF3;n del rat&#xF3;n en el cuadro anterior. Como mouseX y mouseY, estas variables especiales son actualizadas cada vez que draw() es ejecutado. Cuando las combinas, pueden ser usadas para dibujar l&#xED;neas continuas al conectar las posiciones actual y m&#xE1;s reciente:

```
function setup() {
  createCanvas(480, 120);
  strokeWeight(4);
  stroke(0, 102);
}

function draw() {
  line(mouseX, mouseY, pmouseX, pmouseY);
}
```

## Ejemplo 5-7: define el grosor sobre la marcha

Las variables pmouseX y pmouseY tambi&#xE9;n pueden ser usadas para calcualr la velocidad del rat&#xF3;n. Esto se hace midiendo la distancia entre la posici&#xF3;n actual y la m&#xE1;s reciente del rat&#xF3;n. Si el rat&#xF3;n se est&#xE1; moviendo lentamente, la distancia es peque&#xF1;a, pero si se empieza a mover m&#xE1;s r&#xE1;pido, la distancia se incrementa. Una funci&#xF3;n llamada dist() simplifica este c&#xE1;lculo, como se muestra en el siguiente ejemplo. Aqu&#xED;, la velocidad del rat&#xF3;n es usada para definir el grosor de la l&#xED;nea dibujada

```
function setup() {
  createCanvas(480, 120);
  stroke(0, 102);
}

function draw() {
  var weight = dist(mouseX, mouseY, pMouseX, pMouseY);
  strokeWeight(weight);
  line(mouseX, mouseY, pmouseX, pmouseY);
}
```
## Ejemplo 5-8: el suavizado lo hace

En el ejemplo 5-7, los valores del rat&#xF3;n son convertidos directamente a posiciones en la pantalla. Pero a veces queremos que estos valores sigan al rat&#xF3;n m&#xE1;s libremente - que se queden atr&#xE1;s para creen un movimiento m&#xE1;s fluido. Esta t&#xE9;cnica es llamada suavizado. Con el suavizado, hay dos valores: el valor actual y el valor objetivo (ver Figura 5-1). A cada paso en el programa, el valor actual se mueve un poco m&#xE1;s cerca del valor objetivo:

```
var x = 0;
var easing = 0.01;

function setup() {
  createCanvas(220, 120);
}

function draw() {
  var targetX = mouseX;
  x += (targetX - x) * easing;
  ellipse(x, 40, 12, 12);
  print(targetX + &quot; : &quot; + x);
}

```

El valor de la variable x est&#xE1; siempre acerc&#xE1;ndose a targetX. La velocidad con la que lo alcanzo es definida por la variable de easing, un n&#xFA;mero entre 0 y 1. Un valor peque&#xF1;o de easing causa m&#xE1;s retraso que un valor m&#xE1;s grande. Con un valor de easing de 1, no hay retraso. Cuando corres el ejemplo 5-8, los valores actuales son mostrados en la consola a trav&#xE9;s de la funci&#xF3;n print(). Cuando muevas el mouse, observa c&#xF3;mo los n&#xFA;meros est&#xE1;n alejados, pero cuando dejas de moverlo, el valor de x se acerca al valor de targetX.

Todo el trabajo en este ejemplo ocurre en la l&#xED;nea que empieza con x+=. Aqu&#xED;, se calcula la diferencia entre el valor objetivo y el actual, y luego es multiplicada por la variable easing y a&#xF1;adida a x para llevarla m&#xE1;s cerca que el objetivo.

## Ejemplo 5-9: suaviza las l&#xED;neas

En este ejemplo, la t&#xE9;cnica de suavizado es aplicada al Ejemplo 5-7. En comparaci&#xF3;n, las l&#xED;neas son m&#xE1;s fluidas:

```
var x = 0;
var y = 0;
var px = 0;
var py = 0;
function setup() {
  createCanvas(480, 120);
  stroke(0, 102);
}

function draw() {
  var targetX = mouseX;
  x += (targetX - x) * easing;
  var targetY = mouseY;
  y += (targetY - y) * easing;
  var weight = dist(x,y,px,py);
  strokeWeight(weight);
  line(x,y,px,py);
  py = y;
  px = x;
}
```
## Click

Adem&#xE1;s de la ubicaci&#xF3;n del rat&#xF3;n, p5.js tambi&#xE9;n mantiene registro de si el bot&#xF3;n del rat&#xF3;n ha sido presionado o no. La variable mouseIsPressed tiene un valor diferente cuando el bot&#xF3;n del rat&#xF3;n est&#xE1; presionado. La variable mouseIsPressed es una variable boolean, lo que significa que solo tiene dos posibles valores: verdadero (true) o falso (falso). El valor de mouseIsPressed es verdadero cuando un bot&#xF3;n es presionado.

## Ejemplo 5-10: haz click con el rat&#xF3;n

La variable mouseIsPressed es usada en conjunto con la declaraci&#xF3;n if para determinar si una l&#xED;nea de c&#xF3;digo ser&#xE1; ejecutada o no. Prueba este ejemplo antes de sigamos explicado:

```
function setup() {
  createCanvas(240, 120);
  strokeWeight(30);
}

function draw() {
  background(204);
  stroke(102);
  line(40, 0, 70, height);
  if (mouseIsPressed == true) {
    stroke(0);
  }
  line(0,70,width,50);
}
```
En este programa, el c&#xF3;digo dentro del blocke if s&#xF3;lo corre cuando el bot&#xF3;n del rat&#xF3;n es presionado. Cuando el bot&#xF3;n no est&#xE1; presionado, el c&#xF3;digo es ignorado. Como el for loop discutido en &quot;Repetition&quot;, el bloque if tiene una prueba (test) que es evaluada a verdadero (true) o falso (false).

```
if (test) {
  statements
}
```

Cuando el test es true, el c&#xF3;digo dentro del bloque es ejecutado y cuando es falso, no es ejecutado. El computador determina si el test es true o false al evaluar la expresi&#xF3;n dentro del par&#xE9;ntesis. (Si quieres refrescar tu memoria, el ejemplo 4-6 discute en mayor detalle expresiones relacionales). El s&#xED;mbolo == compara los valores a la izquierda y la derecha para probar si son equivalentes o no. El s&#xED;mbolo == es diferente del operador de asignaci&#xF3;n, el s&#xED;mbolo unitario =. el s&#xED;mbolo == pregunta, &quot;&#xBF;son estas cosas iguales?&quot;, mientras que el s&#xED;mbolo = define el valor de una variable

## Nota

Es un error com&#xFA;n, incluso para programadores avanzados, escribir = en el c&#xF3;digo en vez de ==. p5.js no siempre te advertir&#xE1; cu&#xE1;ndo lo hagas, as&#xED; que s&#xE9; cuidadoso.

Alternativamente, la prueba en draw() puede ser escrita as&#xED;:

```
if (mouseIsPressed) {
```

Las variables Boolean, incluyendo a mouseIsPressed, no necesitan la comparaci&#xF3;n expl&#xED;cita con el operador ==, porque su valor es solo o true o false.

## Ejemplo 5-11: detecci&#xF3;n de no clickeado

Un bloque if te da la oportunidad de correr una porci&#xF3;n de c&#xF3;digo o de ignorarla. Puedes extender la funcionalidad del bloque if con el bloque else, permitiendo que tu programa escoja entre dos opciones. El c&#xF3;digo dentro del bloque else corre cuando el valor de la prueba del bloque if es false. Por ejemplo, el color de trazado de un programa puede ser negro cuando el bot&#xF3;n del rat&#xF3;n no es presionado y puede cambiar a negro cuando s&#xED; es presionado:

```
function setup() {
  createCanvas(240, 120);
  strokeWeight(30);
}
function draw() {
  background(204);
  stroke(102);
  line(40, 0, 70, height);
  if (mouseIsPressed) {
    stroke(0);
  } else {
    stroke(255);
  }
  line(0, 70, width, 50);
}
```
## Ejemplo 5-12: M&#xFA;ltiples botones del rat&#xF3;n

p5.js tambi&#xE9;n registra cu&#xE1;l bot&#xF3;n del rat&#xF3;n es presionado si es que tienes m&#xE1;s de uno en tu rat&#xF3;n. La variable mouseButton puede tener uno de estos tres valores: LEFT, CENTER o RIGHT. Para probar cu&#xE1;l de los botones es presionado, el operador == es necesario, como se muestra a continuaci&#xF3;n:

```
function setup() {
  createCanvas(120, 120);
  strokeWeight(30);
}

function draw() {
  background(204);
  stroke(102);
  line(40, 0, 70, height);
  if (mouseIsPressed) {
    if (mouseButton == LEFT) {
      stroke(255);
    } else {
      stroke(0);
    }
    line(0,70,width,50);
  }
}
```

Un programa puede tener muchas m&#xE1;s estructuras if y else (ver Figura 5-2) que las encontradas en estos ejemplos cortos. Pueden ser concatenadas en una larga serie con distintas pruebas, y los bloques if pueden estar anidados dentro de otros bloques if para hacer decisiones m&#xE1;s complejas.

## Ubicaci&#xF3;n

Una estructura if puede ser usada con los valores de mouseX y mouseY para determinar la ubicaci&#xF3;n del cursos dentro de la ventana.

## Ejemplo 5-13: encuentra el cursos

En este ejemplo, buscamos el cursor para ver si est&#xE1; a la izquierda o hacia la derecha de la l&#xED;nea y luego movemos la l&#xED;nea hacia el cursor:

```
var x;
var offset = 10;

function setup() {
  createCanvas(240, 120);
  x = width/2;
}

function draw() {
  background(204);
  if (mouseX &gt; x) {
    x += 0.5;
    offset = -10;
  }
  if (mouseX &lt; x) {
    x -= 0.5;
    offset = 10;
  }
  //dibuja una flecha izquierda o derecha seg&#xFA;n el valor del &quot;offset&quot;
  line(x, 0, x, height);
  line(mouseX, mouseY, mouseX + offset    , mouseY - 10);
  line(mouseX, mouseY, mouseX + offset    , mouseY + 10);
  line(mouseX, mouseY, mouseX + offset * 3, mouseY);
}
```

Para escribir programas que tengan interfaces gr&#xE1;ficas de usuario (botones, casillas, barras deslizadoras, etc.) necesitamos escribir c&#xF3;digo que sepa cuando el curso est&#xE1; dentro de un &#xE1;rea de la pantalla. Los siguientes dos ejemplos introducen c&#xF3;mo verificar si el cursor est&#xE1; dentro de un c&#xED;rculo y de un rect&#xE1;ngulo. El c&#xF3;digo est&#xE1; escrito en una forma modular variables, para que pueda ser usado para comprobar con cualquier c&#xED;rculo o rect&#xE1;ngulo mediante la modificaci&#xF3;n de los valores.

## Ejemplo 5-14: los bordes de un c&#xED;rculo

Para la prueba con el c&#xED;rculo, usamos la funci&#xF3;n dist() para obtener la distancia desde el centro del c&#xED;rculo al cursor, luego probamos si este valor es menor que el radio del c&#xED;rculo (ver Figura 5-3). Si lo es, sabemos que estamos dentro del c&#xED;rculo. En este ejemplo, cuando el cursos est&#xE1; denrro del &#xE1;rea del c&#xED;rcuo, su tama&#xF1;o aumenta:

```
var x = 120;
var y = 60;
var radius = 12;

function setup() {
  createCanvas(240, 120);
  ellipseMode(RADIUS);
}

function draw() {
  background(204);
  var d = dist(mouseX, mouseY, x, y);
  if (d &lt; radius) {
    radius++;
    fill(0);
  } else {
    fill(255);
  }
  ellipse(x, y, radius, radius);
}
```

## Ejemplo 5-15: Los bordes de un rect&#xE1;ngulo

Usaremos otro enfoque para probar si el curso est&#xE1; dentro de un rect&#xE1;ngulo. Hacemos cuatro pruebas separadas para comprobar si el cursor est&#xE1; en el lado correcto de cada uno de los lados del rect&#xE1;ngulo, luego comparamos cada resultado de las pruebas y si todas son true, entonces sabemos que el cursor est&#xE1; dentro. Esto es ilustrado en la Figura 5-4. Cada paso es simple, pero lucen complicados al combinarse entre s&#xED;:

```
var x = 80;
var y = 30;
var w = 80;
var h = 60;

function setup() {
  createCanvas(240, 120);
}

function draw() {
  background(204);
  if ((mouseX &gt; x) &amp;&amp; (mouseX &lt; x+w) &amp;&amp;
      (mouseY &gt; y) &amp;&amp; (mouseY &lt; y+h)) {
        fill(0);
      } else {
        fill(255);
      }
      rect(x, y, w, h);
}
```

La prueba en la declaraci&#xF3;n if es un poco m&#xE1;s complicada que lo que hemos visto hasta el momento. Cuatro pruebas individuales (como mouseX &gt; x) son combinadas con el operador l&#xF3;gico AND, el s&#xED;mbolo &amp;&amp;, para asegurarse que cada expresi&#xF3;n relacional en la secuencia sea true. Si alguna de ellas es false, el test entero es false y el color de relleno no ser&#xE1; negro.

## Tipo

p5.js mantiene registro de cualquier tecla que sea presionada en el teclado, adem&#xE1;s de la &#xFA;ltima tecla presionada. Tal como la variable mouseIsPressed, la variable keyIsPressed is true cuando cualquier tecla es presionada, y false cuando no hay teclas presionadas.

## Ejemplo 5-16: presiona una tecla

En este ejemplo, la segunda l&#xED;nea es dibujada solo cuando hay una tecla presionada:

```
function setup() {
  createCanvas(240, 120);
}

function draw() {
  background(204);
  line(20, 20, 220, 100);
  if (keyIsPressed) {
    line(220, 20, 20, 100);
  }
}
```

La variable key guarda la tecla presionada m&#xE1;s recientemente. A diferencia de la variable boolean keyIsPressed, que se revierte a false cada vez que la tecla es soltada, la variable key mantiene su valor hasta que la siguiente tecla es presionada. El siguiente ejemplo usa el valor de key para dibujar el caracter en la pantalla. Cada vez qeu una nueva tecla es presionada, el valor se actualiza y un nuevo caracter es dibujado. Algunas teclas, como Shift y Alt, no tienen un caracter visible, as&#xED; que si las presionas, nada ser&#xE1; dibujado.

## Ejemplo 5-17: dibuja algunas letras

Este ejemplo introduce la funci&#xF3;n textSize() para definir el tama&#xF1;o de las letras, la funci&#xF3;n textAlign() para centrar el texto en su coordenada x y la funci&#xF3;n text() para dibujar la letra. Estas funciones ser&#xE1;n discutidas en mayor detalle en &quot;Fonts&quot;.

```
function setup{
  createCanvas(120,120);
  textSize(64);
  textAlign(CENTER);
  fill(255);
}

function draw() {
  background(0);
  text(key, 60, 80);
}
```
Usando una estructura if, podemos probar si una tecla espec&#xED;fica es presionad y escoger dibujar algo distinto en la pantalla a modo de respuesta.

## Ejemplo 5-18: revisar diferentes teclas

En este ejemplo, revisamos si las teclas N o H son presionadas. Usamos el comparador de comparaci&#xF3;n, el s&#xED;mbolo ==, para revisar si el valor de la variable key es igual a los caracteres que estamos buscando:

```
function setup() {
  createCanvas(120, 120);
}

function draw() {
  background(204);
  if (keyIsPressed) {
    if ((key == &apos;h&apos;) || (key == &apos;H&apos;)) {
      line(30, 60, 90, 60);
    }
    if ((key == &apos;n&apos;) || (key == &apos;N&apos;)) {
      line(30, 20, 90, 100);
    }
  }
  line(30, 20, 30, 100);
  line(90, 20, 90, 100);
}
```
Cuando revisamos si est&#xE1; siendo presionada la tecla H o la N, necesitamos revisar tanto para las letras en may&#xFA;scula como en min&#xFA;scula, en caso de que alguien presione la tecla Shift o tenga la funci&#xF3;n Caps Lock activada. Combinamos ambas pruebas con el operador l&#xF3;gico OR, el s&#xED;mbolo ||. Si traducimos la segunda declaraci&#xF3;n if en este ejemplo a lenguaje plano, dice &quot;Si la tecla &apos;h&apos; es presionada OR la tecla &apos;H&apos; es presionada&quot;. A diferencia del operador l&#xF3;gico AND (el s&#xED;mbolo &amp;&amp;), solo una de estas expresiones necesita ser true para que la prueba entera sea evaluada a true.

Algunas teclas son m&#xE1;s dif&#xED;ciles de detectar, porque no est&#xE1;n asociadas a una letra en particular. Teclas como Shift, Alt, y las flechas est&#xE1;n codificadas. Tenemos que revisar el c&#xF3;digo con la variable keyCode para revisar qu&#xE9; tecla es. Los valores m&#xE1;s frecuentes de keyCode son ALT, CONTROL y SHIFT, adem&#xE1;s de las teclas con flechas UP_ARROW, DOWN_ARROW, LEFT_ARROW Y RIGHT_ARROW.

## Ejemplo 5-19: mover con las flechas

El siguiente ejemplo muestra c&#xF3;mo usar las flechas izquierda y derecha para mover un rect&#xE1;ngulo.

```
var x = 215;
function setup() {
  createCanvas(480, 120);
}

function draw() {
  if (keyIsPressed) {
    if (keyCode == LEFT_ARROW) {
      x--;
    } else if (keyCode == RIGHT_ARROW) {
      x++;
    }
  }
  rect(x, 45, 50, 50);
}
```
## Toque

Para dispositivos que lo soportan, p5.js mantiene registr de si la pantalla es tocada y su ubicaci&#xF3;n. Como la variable mouseIsPressed, la variable touchIsdown es true cuando la pantalla es tocada, y false cuando no.

## Ejemplo 5-20: toca la pantalla

En este ejemplo, la segunda l&#xED;nea es dibujada solo si la pantalla es tocada

```
function setup() {
  createCanvas(240, 120);
}

function draw() {
  background(204);
  line(220, 20, 220, 100);
  if (touchIsdown) {
    line(220, 20, 20, 100);
  }
}
```
Como las variables mouseX y mouseY, las variables touchX y touchY almacenan las coordenadas x e y del punto donde la pantalla est&#xE1; siendo tocada.

## Ejemplo 5-21: rastrea el dedo

En este ejemplo, un nuevo c&#xED;rculo es a&#xF1;adido al lienzo cada vez que el c&#xF3;digo en draw() es ejecutado. Para refrescar la pantalla y solo mostrar el c&#xED;rculo m&#xE1;s nuevo, escribe la funci&#xF3;n background() al inicio de draw() antes de dibujar la figura:

```
function setup() {
  createCanvas(480, 120);
  fill(0, 102);
  noStroke();
}

function draw() {
  ellipse(touchX, touchY, 15, 15);
}
```

## Mapeo

Los n&#xFA;meros que son creados por el rat&#xF3;n y por el teclado muchas veces necesitan ser modificados para ser &#xFA;tiles dentro del programa. Por ejemplo, si un bosquejo tiene un ancho de 1920 pixeles y los valores de mouseX son usados para definir el color del fondo, el rango de 0 a 1920 de mouseX necesitar&#xE1; ser escalado para moverse en un rango de 0 a 255 para controlar mejor el color. Esta transformaci&#xF3;n puede ser hecha con una ecuaci&#xF3;n o con una funci&#xF3;n llamada map().

## Ejemplo 5-22: mapeo de valores a un rango

En este ejemplo, la ubicaci&#xF3;n de dos l&#xED;neas es controlada por la variable mouseX. La l&#xED;nea gris est&#xE1; sincronizada con la posici&#xF3;n del cursor, pero la l&#xED;nea negra se mantiene m&#xE1;s cerca del centro de la pantalla y se aleja de la l&#xED;nea blanca en los bordes izquierdos y derechos.

```
function setup() {
  createCanvas(240, 120);
  strokeWeight(12);
}

function draw() {
  background(204);
  stroke(102);
  line(mouseX, 0, mouseX, height);  // L&#xED;nea gris
  stroke(0);
  var mx = mouseX/2 + 60;
  line(mx, 0, mx, height);          // L&#xED;nea negra
}
```

La funci&#xF3;n map() es una manera m&#xE1;s general de hacer este tipo de cambio. Convierte una variable desde un rango de valores a otro. El primer par&#xE1;metro es la variable a ser convertida, el segundo y tercer valor son los valores m&#xED;nimo y m&#xE1;ximo de esa variable, y el cuarto y quinto son los valores m&#xED;nimo y m&#xE1;ximo deseados. La funci&#xF3;n map() esconde la matem&#xE1;tica detr&#xE1;s de esta conversi&#xF3;n.

## Ejemplo 5-23: Mapeo con la funci&#xF3;n map()

Este ejemplpo reescribe el Ejemplo 5-22 usando map():

```
function setup() {
  createCanvas(240, 120);
  strokeWeight(12);
}

function draw() {
  background(204);
  stroke(255);
  line(120, 60, mouseX, mouseY);  // L&#xED;nea blanca
  stroke(0);
  var mx = map(mouseX, 0, width, 60, 180);
  line(120, 60, mx, mouseY);      // L&#xED;nea negra
}
```

La funci&#xF3;n map() hace que el c&#xF3;digo sea f&#xE1;cil de leer, porque los valores m&#xE1;ximo y m&#xED;nimo est&#xE1;n claramente escritos como par&#xE1;metros. En este ejemplo, los valores de mouseX entre 0 y width son convertidos a n&#xFA;meros entre 60 (cuando mouseX es 0) y 180 (cuando mouseX es width). Encontrar&#xE1;s esta &#xFA;til funci&#xF3;n map() en muchos ejemplos a lo largo de este libro.

## Robot 3: respuesta

Este programa usa las variables introducidas en Robot 2 (ver &quot;Robot 2: variables&quot;) y hace posible cambiarlas mientras el programa corre de manera que las figuras respondan al rat&#xF3;n. El c&#xF3;digo dentro del bloque draw() es ejecutado muchas veces por segundo. En cada cuadro, las variables definidas en el programa cambian en respuesta a las variables mouseX y mouseIsPressed.

La variable mouseX controla la posici&#xF3;n del robot con la t&#xE9;cnica de suavizado para que los movimientos sean menos instant&#xE1;neos y se vean m&#xE1;s naturales. Cuando un bot&#xF3;n del rat&#xF3;n es presionado, los valores de neckHeight y bodyHeight cambian para hacer al robot m&#xE1;s corto:

```
var x = 60;           // Coordenada x
var y = 440;          // Coordenada y
var radius = 45;      // Radio de la cabeza
var bodyHeight = 160; // Altura del cuerpo
var neckHeight = 70;  // Altura del cuello

var easing = 0.04;

function setup() {
  createCanvas(360, 480);
  strokeWeight(2);
  ellipseMode(RADIUS);
}

function draw() {
  var targetX = mouseX;
  x += (targetX - x) * easing;
  if (mouseIsPressed) {
    neckHeight = 16;
    bodyHeight = 90;
  } else {
    neckHeight = 70;
    bodyHeight = 160;
  }

  var neckY = y - bodyHeight - neckHeight - radius;

  background(204);

  // Cuello
  stroke(102);
  line(x + 12, y - bodyHeight, x + 12, neckY);

  // Antenas
  line(x + 12, neckY, x - 18, neckY - 43);
  line(x + 12, neckY, x + 42, neckY - 99);
  line(x + 12, neckY, x + 78, neckY + 15);

  // Cuello
  noStroke();
  fill(102);
  ellipse(x, y - 33, 33, 33);
  fill(0);
  rect(x - 45, y - bodyHeight, 90, bodyHeight - 33);

  // Cabeza
  fill(0);
  ellipse(x + 12, neckY, radius, radius);
  fill(255);
  ellipse(x + 24, neckY - 6, 14, 14);
  fill(0);
  ellipse(x + 24, neckY - 6, 3, 3);
}
```
</section>

<a id="prev-link" href="chapter04.html">Previous: Capítulo 4. Variables</a>

<a id="next-link" href="chapter06.html">Next: Capítulo 6. Trasladar, rotar, escalar</a>
    </div>
  </body>
</html>
