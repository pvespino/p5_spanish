<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Introducción a p5.js</title>
    
    <link rel="stylesheet" href="assets/pdf.css">

  </head>
  <body data-type="book">
    <nav data-type='toc'>
  <h1>Table of Contents</h1>
  <ol>
<li>
  <a href="#preface">Prefacio</a>
</li>
<li>
  <a href="#capitulo_01_hola">Capítulo 1. Hola </a>
</li>
<li>
  <a href="#capitulo_02_empezando_a_programar">Capítulo 2. Empezando a programar</a>
</li>
<li>
  <a href="#capitulo_03_dibuja">Capítulo 3. Dibuja</a>
</li>
<li>
  <a href="#capitulo_04_variables">Capítulo 4. Variables</a>
</li>
<li>
  <a href="#capitulo_07_medios">Capítulo 5. Respuesta</a>
</li>
<li>
  <a href="#capitulo_06_trasladar">Capítulo 6. Trasladar, rotar, escalar</a>
</li>
<li>
  <a href="#capitulo_08_movimiento">Capítulo 8. Movimiento</a>
</li>
<li>
  <a href="#capitulo_09_funciones">Capítulo 9. Funciones</a>
</li>
<li>
  <a href="#capitulo_10_objetos">Capítulo 10. Objetos</a>
</li>
<li>
  <a href="#capitulo_11_arreglos">Capítulo 11. Arreglos</a>
</li>
<li>
  <a href="#capitulo_12_datos">Capítulo 12. Datos</a>
</li>
<li>
  <a href="#capitulo_13_extension"> Capítulo 13. Extensión </a>
</li>
  </ol>
</nav>


<section data-type="preface" id="preface">

    <script src="//toolness.github.io/p5.js-widget/p5-widget.js"></script>

    <h1>Prefacio</h1>

    <p>p5.js est&#xE1; inspirado y guiado por otro proyecto, que empez&#xF3; hace 15 a&#xF1;os. En el a&#xF1;o 2001, Casey Reas y Ben Fry empezaron a trabajar en una nueva plataforma para hacer m&#xE1;s f&#xE1;cil la programaci&#xF3;n de gr&#xE1;ficas interactiva, la nombraron Processing. Ellos estaban frustrados por lo dif&#xED;cil que era escribir este tipo de software con los lenguajes que normalmente usaban (C++ y Java), y fueron inspirados por lo simple que era escribir programas interesantes con los lenguajes que usaban cuando ni&#xF1;os (Logo y BASIC). Su mayor influencia fue Design by Numbers (DBN), un lenguaje que ellos estaban trabajando en mantenimiento y ense&#xF1;ando en ese tiempo (y que fue creado por su tutor de investigaci&#xF3;n, John Maeda).</p>

    <p>Con Processing, Ben y Casey estaban buscando una mejor manera de probar sus ideas en c&#xF3;digo, en vez de solo conversarlas o pasar demasiado tiempo program&#xE1;ndolas en C++. Su otro objetivo era construir un lenguaje para ense&#xF1;ar c&#xF3;mo programar a estudiantes de dise&#xF1;o y de arte y tambi&#xE9;n brindarles una manera m&#xE1;s f&#xE1;cil de trabajar con gr&#xE1;ficas a estudiantes m&#xE1;s avanzados. Esta combinaci&#xF3;n es una desviaci&#xF3;n positiva de la manera en que com&#xFA;nmente se ense&#xF1;a programaci&#xF3;n. Los nuevos usuarios empiezan concentr&#xE1;ndose en gr&#xE1;ficas e interacci&#xF3;n en vez de estructuras de datos y resultados en forma de texto en la consola.</p>

    <p>A trav&#xE9;s de los a&#xF1;os, Processing se ha transformado en una gran comunidad. Es usado en salas de clases en todo el mundo, en planes de estudios de artes, humanidades y ciencias de la computaci&#xF3;n, adem&#xE1;s de profesionales.</p>

    <p>Hace dos a&#xF1;os, Ben y Casey se me acercaron con una pregunta: &#xBF;c&#xF3;mo se ver&#xED;a Processing si funcionara en la web? p5.js empieza con el objetivo original de Processing, hacer que programar sea accesible para artistas, dise&#xF1;adores, educadores y principiantes, y luego lo reinterpreta para la web actual usando Javascript y HTML.</p>

    <p> El desarrollo de p5.js ha sido como acercar mundos distintos. Para facilitar la transici&#xF3;n a la Web de los usuarios de la existente comunidad de Processing, nos adherimos a la sintaxis y a las convenciones de Processing tanto como fuera posible. Sin embargo, p5.js est&#xE1; construido con Javascript, mientras que Processing est&#xE1; construido con un lenguaje llamado Java. Estos dos lenguajes tienen distintos patrones y funciones, as&#xED; que a en ocasiones nos tuvimos que desviar de la sintaxis de Processing. Tambi&#xE9;n fue importante que p5.js fuera integrado sin problemas a las existentes caracter&#xED;sticas, herramientas y marcos de la web, para atraer usuarios familiarizados con la web pero novatos en programaci&#xF3;n creativa. Sintetizar todos estos factores fue un gran desaf&#xED;o, pero el objetivo de unir estos marcos proporcion&#xF3; un camino claro a seguir en el desarrollo de p5.js.</p>

    <p>Una primera versi&#xF3;n beta fue lanzada en agosto del 2014. Desde ese entonces, ha sido usado e integrado a programas de estudios en todo el mundo. Existe un editor oficial de p5.js que est&#xE1; actualmente en desarrollo, y ya se ha avanzado en muchas nuevas caracter&#xED;sticas y librer&#xED;as. </p>

    <p> p5.js es un esfuerzo comunitario - cientos de personas han contribuido funciones esenciales, soluciones a errores, ejemplos, dise&#xF1;o, reflexiones y discusi&#xF3;n. Pretendemos continuar la visi&#xF3;n y el esp&#xED;ritu de la comunidad de Processing mientras la abrimos a&#xFA;n m&#xE1;s en la Web.</p>

    <h2>C&#xF3;mo este libro est&#xE1; organizado</h2>

    <p>Los cap&#xED;tulos de este libro est&#xE1;n organizados de la siguiente manera:</p>

    <ul>
        <li> 1/Hola: aprende sobre p5.js</li>
        <li> 2/Aprendiendo a programar: crea tu primer programa en p5.js</li>
        <li> 3/Dibujar: define y dibuja figuras simples</li>
        <li> 4/Variables: almacena, modifica y reusa datos</li>
        <li> 5/Respuesta: controla e influencia programas con el rat&#xF3;n, teclado y toques.</li>
        <li> 6/Trasladar, rotar, escalar: transforma las coordenadas</li>
        <li> 7/Media: carga y muestra medios, incluyendo im&#xE1;genes y tipograf&#xED;as</li>
        <li> 8/Movimiento: mueve y haz coreograf&#xED;a de figuras</li>
        <li> 9/Funciones: construye nuevos m&#xF3;dulos de c&#xF3;digo</li>
        <li> 10/Objetos: crea m&#xF3;dulos de c&#xF3;digo que combinan variables y funciones</li>
        <li> 11/Arreglos: simplifica el trabajo con listas de variables</li>
        <li> 12/Datos: carga y visualiza datos</li>
        <li> 13/Extensi&#xF3;n: aprender sobre sonido y DOM</li>
    </ul>

    <h2>Para qui&#xE9;n es este libro</h2>

    <p>Este libro fue escrito para personas que quieren crear im&#xE1;genes y programas interactivos simples a trav&#xE9;s de una casual y concisa introducci&#xF3;n a la programaci&#xF3;n de computadores. Es para personas que quieren una ayuda para entender los miles de ejemplos de c&#xF3;digo en p5.js y los manuales de referencia disponibles en la web de manera gratuita. Introducci&#xF3;n a p5.js no es un libro de referencia sobre programaci&#xF3;n. Como el t&#xED;tulo sugiere, te har&#xE1; una introducci&#xF3;n. Es para adolescentes, entusiastas, abuelos, y cualquier persona entremedio.</p>

    <p>Este libro es apropiado tambi&#xE9;n para personas con experiencia en programaci&#xF3;n que quieren aprender los conceptos b&#xE1;sicos sobre gr&#xE1;ficas de computador interactivas. Introducci&#xF3; a p5.js contiene t&#xE9;cnicas que pueden ser aplicadas a crear juegos, animaciones e interfaces.</p>

    <h2>Convenciones usadas en este libro</h2>

    <p>Las siguientes convenciones tipogr&#xE1;ficas son usadas en este libro:</p>

    <h2>Usando los ejemplos de c&#xF3;digo</h2>

    <p>El material complementario (ejemplos de c&#xF3;digo, ejercicios, etc.) est&#xE1; disponble para descarga en http://github.com/lmccart/gswp5.js-code.</p>

    <p>Este libro est&#xE1; aqu&#xED; para ayudarte a que puedas hacer tu trabajo. En general, puedes usar el c&#xF3;digo en este libro en tus programas y documentaci&#xF3;n. No necesitas contactarnos para permiso a menos que est&#xE9;s reproduciendo una porci&#xF3;n significativa del c&#xF3;digo.
        Por ejemplo, si est&#xE1;s escribiendo un programa que usa m&#xFA;ltiples trozos de c&#xF3;digo de este libro no requiere permiso. Vender o distribuir ejemplos de libros Make: s&#xED; requiere permiso. Responder una pregunta citando este libro y citando ejemplos
        de c&#xF3;digo no requiere permiso. Incorporar un monto significativo de c&#xF3;digo de ejemplo de este libro en la documentaci&#xF3;n de tu producto s&#xED; requiere permiso.
    </p>

    <h2>Agradecimientos</h2>

    <p>Le agradecemos a Brian Jepson y Anna Kaziunas France por su gran energ&#xED;a, apoyo y visi&#xF3;n.</p>

    <p>No nos imaginamos este libro sin el ejemplo de Introducci&#xF3;n a Arduino de Massimo Banzi. Este excelente libro de Massimo es el prototipo para el nuestro.</p>

    <p>Un peque&#xF1;o grupo de individuos ha, durante a&#xF1;os, contribuido tiempo y energ&#xED;a esenciales a Processing. Dan Shiffman es nuestro compa&#xF1;ero en la Fundaci&#xF3;n Processing, la organizaci&#xF3;n 501(c)(3) que apoya el software Processing. La mayor parte del c&#xF3;digo principal de Processing 2.0 y Processing 3.0 proviene de las mentes brillantes de Andres Colubri y Manindra Moharana.</p>

    <p>Scott Murray, Jamie Kosoy y Jon Gacnik han construido una maravillosa infraestructura web para el proyecto. James Grady est&#xE1; luci&#xE9;ndose en la interfaz de usuario 3.0. Le agradecemos a Florian Jenett por sus a&#xF1;os de trabajo en diversas &#xE1;reas, incluyendo foros, sitio web y dise&#xF1;o. Elie Zananiri y Andreas Schlegel han creado la infraestructura para construir y documentar librer&#xED;as contribuidas y han pasado innumerables horas curando las listas. Muchos otros han contribuido significativamente al
        projecto, los datos precisos est&#xE1;n disponibles en https://github.com/processing.
    </p>

    <p>
        Este libro surgi&#xF3; del proceso de ense&#xF1;ar con Processing en UCLA. Chandler McWilliams ha sido instrumental en definir estas clases. Casey le agradece a los estudiantes de pregrado en el Departamento de Dise&#xF1;o y Artes Mediales en UCLA por su energ&#xED;a y entusiasmo.
        Sus ayudantes del curso han sido grandes colaboradores al definir c&#xF3;mo Processing es ense&#xF1;ado. Agradecimientos a Tatsuya Saito, John Houck, Tyler Adams, Aaron Siegel, Casey Alt, Andres Colubri, Michael Kontopoulos, David Elliot, Christo Allegra,
        Pete Hawkes y Lauren McCarthy.
    </p>

    <p>p5.js es desarrollado por una gran comunidad de contribuidores a lo largo del mundo. Dan Shiffman, Jason Sigal, Sam Lavigne, K. Adam White, Chandler McWilliams, Evelyn Eastmond, los miembros del grupo de trabajo de p5 en ITP, los asistentes a la primera Conferencia de Contribuidores de p5.js en el Frank-Ratchye STUDIO para la Investigaci&#xF3;n Creativa en la Universidad Carnegie Mellon, y los estudiantes y mentores del Processing Google Summer of Code han sido instrumentales en hacer que p5.js sea lo que es hoy. Apoyo significativo para el proyecto ha sido provisto por la Processing Foundation, NYU ITP, RISD y Bocoup. Puedes ver la lista completa de contribuidores en http://p5js.org/contribute/#contributors. Lauren tambi&#xE9;n le agrade a Kyle McDonald por su perpetuo apoyo e inspiraci&#xF3;n.</p>

    <p> Este libro ha sido transformado por las art&#xED;sticas ilustraciones de Taeyoon Choi. Fueron desarrolladas en parte a trav&#xE9;s de una residencia en el Frank-Ratchye STUDIO para la Investigaci&#xF3;n Creativa en la Carnegie Mellon University, con apoyo del programa Art Works del National Endowment for the Arts. Charlotte Stiles ayud&#xF3; tremendamente con la edici&#xF3;n y los ejemplos e im&#xE1;genes de este libro.</p>

    <p>A trav&#xE9;s del financiamento del Aesthetics and Computation Group (1996-2002) en el MIT Media Lab, John Maeda hizo todo esto posible.</p>

</section>

<section data-type="chapter" id="capitulo_01_hola">

    <h1>Cap&#xED;tulo 1. Hola </h1>

    <a data-primary="hola" data-type="indexterm"></a>

    <p>p5.js sirve para escribir software que produce im&#xE1;genes, animaciones e interacciones. La intenci&#xF3;n es escribir una l&#xED;nea de c&#xF3;digo y que un c&#xED;rculo aparezca en la pantalla. A&#xF1;ade unas pocas l&#xED;neas de c&#xF3;digo, y ahora el c&#xED;rculo sigue al rat&#xF3;n. Otra
        l&#xED;nea de c&#xF3;digo, y el c&#xED;rculo cambia de color cuando presionas el rat&#xF3;n. Le llamamos a esto bosquejar con c&#xF3;digo. T&#xFA; escribes una l&#xED;nea, luego a&#xF1;ades otra, luego otra, y as&#xED;. El resultado es el programa creado una pieza a la vez.</p>

    <p>Los cursos de programaci&#xF3;n t&#xED;picamente se enfocan primero en estructura y teor&#xED;a. Cualquier aspecto visual - una interfaz, una animaci&#xF3;n - es considerado un postre que solo puede ser disfrutado despu&#xE9;s de que terminas de comer tus vegetales, equivalente
        a varias semanas de estudiar algoritmos y m&#xE9;todos. A trav&#xE9;s de los a&#xF1;os, hemos visto a muchos amigos tratar de tomar estos cursos, para luego abandonarlos despu&#xE9;s de la primera sesi&#xF3;n o despu&#xE9;s de una muy larga y frustrante noche previa a la entrega
        de la primera tarea. Toda curiosidad inicial que ten&#xED;an sobre hacer que el computador trabaje para ellos es perdida porque no pueden ver un camino claro entre lo que tienen que aprender al principio y lo que quieren crear.</p>

    <p>p5.js ofrece una manera de programar a trav&#xE9;s de la creaci&#xF3;n de gr&#xE1;ficas interactivas. Hay muchas maneras posibles de ense&#xF1;ar c&#xF3;digo, pero los estudiantes usualmente encuentran apoyo y motivaci&#xF3;n en retroalimentaci&#xF3;n visual inmediata. p5.js provee
        esta retroalimentaci&#xF3;n, y su &#xE9;nfasis en im&#xE1;genes, prototipado y comunidad es discutido en las siguientes p&#xE1;ginas.</p>

    <h2>Bosquejo y prototipado</h2>

    <p>Bosquejar es una manera de pensar, es juguet&#xF3;n y r&#xE1;pido. El objetivo b&#xE1;sico es explorar muchas ideas en un corto periodo de tiempo. En nuestro propio trabajo, usualmente empezamos bosquejando en papel y luego trasladando nuestros resultados a c&#xF3;digo.
        Las ideas para animaci&#xF3;n e interacci&#xF3;n son usualmente bosquejadas como un gui&#xF3;n gr&#xE1;fico con anotaciones. Despu&#xE9;s de hacer algunos bosquejos en software, las mejores ideas son seleccionadas y combinadas en prototipos. Es un proceso c&#xED;clico de hacer,
        probar y mejorar que va y viene entre papel y pantalla. </p>

    <h2>Flexibilidad</h2>

    <p>
        Tal como un cintur&#xF3;n de herramientas para software, p5.js consiste de muchas herramientas que funcionan juntas en diversas combinaciones. Como resultado, puede ser usado para exploraciones r&#xE1;pidas o para investigaci&#xF3;n en profundidad. Porque un programa
        hecho con p5.js puede ser tan corto como unas pocas l&#xED;neas de c&#xF3;digo o tan largo como miles, existe espacio para crecimiento y variaci&#xF3;n. Las librer&#xED;as de p5.js lo extienden a otros dominios incluyendo trabajar con sonido y la adici&#xF3;n de botones,
        barras deslizadoras, cajas de entrada y captura de c&#xE1;mara con HTML.
    </p>

    <h2>Gigantes</h2>

    <p>
        Las personas han estado haciendo im&#xE1;genes con computadores desde los a&#xF1;os 1960s, y hay mucho que podemos aprender de esta historia. Por ejemplo, antes de que los computadores pudieran proyectar a pantallas CRT o LCd, se usaban grandes m&#xE1;quinas trazadoras
        para dibujar las im&#xE1;genes. En la vida, todos nos paramos sobre hombros de gigantes, y los titanes para p5.js incluyen pensadores del dise&#xF1;o, gr&#xE1;fica computacional, arte, arquitectura, estad&#xED;stica y disciplinas intermedias. Dale un vistazo a Sketchpad
        (1963) por Ivan Sutherland, Dynabook (1968) por Alan Kay y otros artistas destacados en Artist and Computer (Harmony Books, 1976) por Ruth Leavitt. El ACM SIGGRAPH y Ars Electronica brindan atisbos fascinantes en la historia de la gr&#xE1;fica y el
        software.
    </p>

    <h2>&#xC1;rbol famiiliar</h2>

    <p>
        Como los lenguajes humanos, los lenguajes de programaci&#xF3;n pertenecen a familias de lenguajes relacionados. p5.js es un dialecto de un lenguaje de programaci&#xF3;n llamado Javascript. La sintaxis del lenguaje es casi id&#xE9;ntica, pero p5.js a&#xF1;ade caracter&#xED;sticas
        personalizadas relacionadas a gr&#xE1;ficas e interacci&#xF3;n y provee un acceso simple a caracter&#xED;sticas de HTML5 nativas que ya est&#xE1;n soportadas por los navegadores web. Por estas caracter&#xED;sticas compartidas, aprender p5.js es un paso &#xFA;til para aprender
        a programar en otros lenguajes y usar otras herramientas computacionales.
    </p>

    <h2>&#xDA;nete</h2>

    <p>
        Miles de personas usan p5.js cada d&#xED;a. Como ellos, t&#xFA; puedes descargar p5.js gratuitamente. Incluso tienes la opci&#xF3;n de modificar el c&#xF3;digo de p5.js para que se adapte a tus necesidades. p5.js es un proyecto FLOSS (esto es, free/libre/open source software)
        y en el esp&#xED;ritu de esta comunidad, te alentamos a participar y compartir tus proyectos y tu conocimiento en l&#xED;nea en http://p5js.org.
    </p>

</section>

<section data-type="chapter" id="capitulo_02_empezando_a_programar">

<h1>Cap&#xED;tulo 2. Empezando a programar</h1>

<a data-primary="empezando a programar" data-type="indexterm"></a>

<p>
Para sacar el m&#xE1;ximo provecho de este libro, no basta con solo leerlo. Necesitas experimentar y practica. No puedes aprender a programar solamente leyendo - debes hacerlo. Para empezar, descarga p5.js y haz tu primer bosquejo.
</p>

<h2>Ambiente</h2>

Primero, necesitar&#xE1;s un editor de c&#xF3;digo. Un editor de c&#xF3;digo es similar a un editor de texto (como Bloc de notas), excepto que tiene una funcionalidad especial para editar c&#xF3;digo en vez de texto plano. Puedes usar cualquier editor que quieras, te recomendamos Atom y Brackets, ambos disponibles para descarga.
Tambi&#xE9;n existe un editor oficial de p5.js en desarrollo. Si lo quieres usar, lo puedes descargar visitando http://p5js.org/download y seleccionando el bot&#xF3;n que dice &quot;Editor&quot;. Si est&#xE1;s usando el editor de p5.js, puedes saltar a la secci&#xF3;n &quot;Tu primer programa&quot;.

<h2>Descarga y configuraci&#xF3;n de archivos</h2>

Empieza por visitar http://p5js.org/download y selecciona &quot;p5.js complete&quot;. Tras la descarga, haz doble click en el archivo .zip y arrastra el directorio a alguna ubicaci&#xF3;n en tu disco duro. Puede ser Archivos de programa o Documentos o simplemente tu Escritorio, pero lo importante es que el directorio p5 sea extra&#xED;do de este archivo .zip.
El directorio p5 contiene un proyecto de ejemplo con el que puedes empezar a trabajar. Abre tu editor de c&#xF3;digo. Luego abre el directorio llamado &quot;empty-example&quot; en tu editor de c&#xF3;digo. En la mayor&#xED;a de los editores de c&#xF3;digo, puedes hacer esto seleccionando en el men&#xFA; Archivo la opci&#xF3;n Abrir, y luego seleccionando &quot;empty-example&quot;. &#xA1;Ahora est&#xE1;s listo para empezar tu primer programa!

<h2>Tu primer programa</h2>

Cuando abras el directorio &quot;empty-example&quot;, lo m&#xE1;s probable es que veas una barra lateral con el nombre del directorio en la parte superior y una lista con los archivos contenidos en este directorio. Si haces click en alguno de estos archivos, ver&#xE1;s los contenidos del archivo aparecer en el &#xE1;rea principal.

Un bosquejo en p5.js est&#xE1; compuesto de unos cu&#xE1;ntos lenguajes distintos usados en conjunto. HTML (HyperText Markup language) brinda la columna vertebral, enlazando todos los otros elementos en la p&#xE1;gina. Javascript (y la librer&#xED;a p5.js) te permiten crear gr&#xE1;ficas interactivas que puedes mostrar en tu p&#xE1;gina HTML. A veces CSS (Cascading Style Sheets) es usado para definir elementos de estilo en la p&#xE1;gina HTML, pero no cubriremos esta materia en este libro.

Si revisas el archivo index.html, te dar&#xE1;s cuenta que contiene un poco de c&#xF3;digo HTML. Este archivo brinda la estructura a tu projecto, uniendo la librer&#xED;a p5.js y otro archivo llamado sketch.js, donde t&#xFA; escribiras tu propio programa. El c&#xF3;digo que crea estos enlaces tiene esta apariencia:

<pre data-code-language="javascript" data-type="programlisting">
<script language="javascript" type="text/javascript" src="../p5.js"></script>
<script language="javascript" type="text/javascript" src="sketch.js"></script>
</pre>

No necesitas hacer nada en el c&#xF3;digo HTML en este momento - ya est&#xE1; configurado para ti. Luego, haz click en sketch.js y revisa el c&#xF3;digo:


<script type="text/p5" data-autoplay="" data-preview-width="400">
function setup() {
  // put setup code here
}

function draw() {
  // put drawing code here
}
</script>


<div class="codesplit"><div class="pairs"><div class="pair no-comment"><div class="code">

<pre><code>

</code></pre></div></div></div></div>

<p> El c&#xF3;digo plantilla contiene dos bloques, o funciones, setup() y draw(). Puedes poner tu c&#xF3;digo en cualquiera de los dos lugares, y cada uno tiene un prop&#xF3;sito espec&#xED;fico. </p>

<p>Cualquier c&#xF3;digo que est&#xE9; involucrado en la definici&#xF3;n del estado incial de tu programa corresponde al bloque setup(). Por ahora, lo dejaremos vac&#xED;o, pero m&#xE1;s adelante en el libro, a&#xF1;adir&#xE1;s c&#xF3;digo aqu&#xED; para especificar el tama&#xF1;o de tu lienzo para tus gr&#xE1;ficas, el peso de tu trazado o la velocidad de tu programa.</p>

<p>Cualquier c&#xF3;digo involucrado en realmente dibujar contenido a la pantalla (definir el color de fondo, dibujar figuras, texto o im&#xE1;genes) ser&#xE1; colocado en el bloque draw(). Es aqu&#xED; donde empezar&#xE1;s a escribir tus primeras l&#xED;neas de c&#xF3;digo.</p>


<h2>Ejemplo 2-1: dibuja una elipse</h2>

Entre las llaves del bloque draw(), borra el texto //put drawing code here y reempl&#xE1;zalo con el siguiente:

<div class="codesplit"><div class="pairs"><div class="pair no-comment"><div class="code">

<pre><code>background(204);
ellipse(50, 50, 80, 80);

</code></pre></div></div></div></div>

Tu programa entero deber&#xE1; verse as&#xED;:

Esta nueva l&#xED;nea de c&#xF3;digo significa &quot;dibuja una elipse, con su centro 50 pixeles a la derecha desde el extremo izquierdo y 50 pixeles hacia abajo desde el extremo superior, con una altura y un ancho de 80 pixeles&quot;. Graba el c&#xF3;digo presionando Command-S, o desde el men&#xFA; con File-Save.

Para ver el c&#xF3;digo corriendo, puedes abrir index.html en cualquier navegador web (como Chrome, Firefox o Safari). Navega al directorio &quot;empty-example&quot; en tu explorador de archivos y haz doble click en index.html para abrirlo. Otra alternativa es desde el navegador web, escoger Archivo-Abrir y seleccionar el archivo index.html.

Si has escrito todo correctamente, deber&#xED;as ver un c&#xED;rculo en tu navegador. Si no lo ves, aseg&#xFA;rate de haber copiado correctamente el c&#xF3;digo de ejemplo. Los n&#xFA;meros tienen que estar entre par&#xE9;ntesis y tener comas entre ellos. La l&#xED;nea debe terminar con un punto coma.

Una de las cosas m&#xE1;s dif&#xED;ciles sobre empezar a programar es que tienes que ser muy espec&#xED;fico con la sintaxis. El software p5.js no es siempre suficientemente inteligente como para entender lo que quieres decir, y puede ser muy exigente con la puntuaci&#xF3;n. Te acostumbrar&#xE1;s a esto con un poco de pr&#xE1;ctica.

A continuaci&#xF3;n, avanzaremos para hacer esto un poco m&#xE1;s emocionante.

<h2>Ejemplo 2-2: hacer c&#xED;rculos</h2>

Borra el texto del ejemplo anterior, y prueba este. Graba tu c&#xF3;digo, y refresca (Command-R) index.html en tu navegador para verlo actualizado.

Este programa crea un lienzo para gr&#xE1;ficas que tiene un ancho 480 pixeles y una altura de 120 pixeles, y luego empieza a dibujar c&#xED;rculos blancos en la posici&#xF3;n de tu rat&#xF3;n. Cuando presionas un bot&#xF3;n del rat&#xF3;n, el color del c&#xED;rculo cambia a negro. Explicaremos despu&#xE9;s y en detalle m&#xE1;s de los elementos de este programa. Por ahora, corre el c&#xF3;digo, mueve el rat&#xF3;n y haz click para experimentarlo.

<h2>La consola</h2>

El navegador web tiene incluida una consola que puede ser muy &#xFA;til para depurar programas. Cada navegador tiene una manera diferente de abrir la consola. Aqu&#xED; est&#xE1;n las instrucciones sobre c&#xF3;mo hacerlo con los navegadores m&#xE1;s t&#xED;picos:

Para abrir la consola en Chrome, desde el men&#xFA; superior escoge View-Developer-Javascript Console

Con Firefox, desde el men&#xFA; superior escoge Tools-Web-Developer-Web Console.

Usando Safari, necesitar&#xE1;s habilitar la funcionalidad antes de que puedas usarla. Desde el men&#xFA; superior, selecciona Preferencias y luego haz click en la pesta&#xF1;a Avanzado y activa la casilla &quot;Show develop menu in menu bar&quot;. Tras hacer esto, ser&#xE1;s capaz de seleccionar Develop-Show Error Console.

En Internet Explorer, abre F12 Developer Tools, luego selecciona Console Tool.

Deber&#xED;as ahora ver un recuadro en la parte inferior o lateral de tu pantalla. Si hay un error de digitaci&#xF3;n, aparecer&#xE1; texto rojo explicando qu&#xE9; error es. Este texto puede a veces ser cr&#xED;ptico, pero si revisas al lado derecho de la l&#xED;nea, estar&#xE1; el nombre del archivo y el n&#xFA;mero de la l&#xED;nea de c&#xF3;digo donde fue detectado el error. Ese es un lugar adecuado donde empezar a buscar errores en tu programa.

<h2>Creando un nuevo proyecto</h2>

Haz creado un bosquejo desde un ejemplo vac&#xED;o, &#xBF;pero c&#xF3;mo creas un nuevo proyecto? La manera m&#xE1;s f&#xE1;cil de hacerlo es ubicando el directorio &quot;empty-example&quot; en tu explorador de archivos y luego copiar y pegarlo para crear un segundo &quot;empty-example&quot;. Puedes renombrar la carpeta a lo que quieras - por ejemplo, Proyecto 2.

Ahora puedes abrir este directorio en tu editor de c&#xF3;digo y empezar a hacer un nuevo bosquejo. Cuando quieras verlo en el navegador, abre el archivo index.html dentro de tu nuevo directorio Proyecto 2.

Siemrpe es una buena idea grabar tus bosquejos frecuentemente. Mientras est&#xE1;s probando cosas nuevas, graba tu bosquejo con diferentes nombres (Archivo-Guardar como), para que as&#xED; siempre seas capaz de volver a versiones anteriores. Esto es especialmente &#xFA;til si - o cuando - algo se rompe.

<h2>Nota</h2>

Un error com&#xFA;n es estar editando un proyecto pero estar viendo otro en el navegador web, haciendo que no puedas ver los cambios que has hecho. Si te das cuenta que tu programa se ve igual a pesar de haber hecho cambios a tu c&#xF3;digo, revisa que est&#xE1;s viendo el archivo index.html correcto.

<h2>Ejemplos y referencia</h2>

Aprender c&#xF3;mo programar con p5.js involucra explorar mucho c&#xF3;digo: correr, alterar, romper y mejorarlo hasta que lo hayas reformulado en algo nuevo. Con esto en mente, el sitio web de p5.js tiene docenas de ejemplos que demuestran diferentes caracter&#xED;sticas de la librer&#xED;a. Visita la pag&#xED;na de Ejemplos para verlos. Puedes jugar con ellos editanto el c&#xF3;digo en la p&#xE1;gina y luego haciendo click en &quot;Run&quot;. Los ejemplos est&#xE1;n agrupados en distintas categor&#xED;as seg&#xFA;n su funci&#xF3;n, como Forma, color, e imagen. Encuentra un tema que te interese en la lista y prueba un ejemplo.

Si ves una parte del programa con la que no est&#xE1;s familiarizado o sobre la que quieres aprender su funcionalidad, visita la referencia de p5.js.

La referencia de p5.js explica cada elemento de c&#xF3;digo con una descripci&#xF3;n y ejemplos. Los programas en la Referencia son mucho m&#xE1;s cortos (usualmente cuatro o cinco l&#xED;neas) y m&#xE1;s f&#xE1;ciles de seguir que los ejemplos de la p&#xE1;gina Learn. Ten en cuenta que estos ejemplos usualmente omiten setup() y draw() por simplicidad, pero estas l&#xED;neas de c&#xF3;digo que ves deber&#xE1;n ser puestas dentro de uno de estos bloques para poder se ejecutadas. Recomendamos mantener la p&#xE1;gina de Referencia abierta mientras est&#xE1;s leyendo este libro y mientras est&#xE1;s programando. Puede ser navegada por tema o usando la barra de b&#xFA;squeda en la parte superior de la p&#xE1;gina.

La Referencia fue escrita con el principiante en mente, esperamos que sea clara y entendible. Estamos muy agradecidos de las personas que han visto errores y los han se&#xF1;alado. Si crees que puedes mejorar una entrada en al referencia o que has encontrado alg&#xFA;n error, por favor haznos saber esto haciendo click en el link en la parte inferior de la p&#xE1;gina de referencia.

</section>

<section data-type="chapter" id="capitulo_03_dibuja">


<h1>Cap&#xED;tulo 3. Dibuja</h1>

<p>
Al principio, dibujar en una pantalla de computador es como trabajar en papel cuadriculado. Parte como un procedimiento t&#xE9;cnico cuidadoso, pero a medida que se introducen nuevos conceptos, dibujar formas simples con software se transforma en trabajar con animaci&#xF3;n e interacci&#xF3;n. Antes de que hagamos este salto, tenemos que empezar por el principio.
</p>

<p>
Una pantalla de computador es una matriz de elementos de luz llamados pixeles. Cada pixel tiene una posici&#xF3;n dentro de la matriz definida por coordenadas. Cuando creas un bosquejo en p5.js, lo puedes visualizar con un navegador web. Dentro de la ventana del navegador, p5.js create un lienzo para dibujar, un &#xE1;rea en la que se dibujan las gr&#xE1;ficas. El lienzo puede ser del mismo tama&#xF1;o que la ventana, o puede tener dimensiones distintas. El lienzo est&#xE1; usualmente posicionado en la esquina superior izquierda de tu ventana, pero lo puedes posicionar en otros lugares.
</p>

<p>
Cuando dibujas en el lienzo, la coordenada x es la distancia desde el borde izquierdo del lienzo y la coordenada y es la distancia desde el borde superior. Escribimos las coordenadas de un pixel as&#xED; (x,y). As&#xED; que, si el lienzo es de 200 x 200 pixeles, la esquina superior izquierda es (0,0), el centro est&#xE1; en (100, 100) y la esquina inferior derecha es (199, 199). Estos n&#xFA;meros pueden parecer confusos, &#xBF;por qu&#xE9; contamos de 0 a 199 en vez de 1 a 200? La respuesta es que en programaci&#xF3;n, usualmente contamos partiendo en 0 por qu&#xE9; es m&#xE1;s f&#xE1;cil as&#xED; hacer c&#xE1;lculos que veremos m&#xE1;s adelante.
</p>

<h2>El lienzo</h2>

<p>
El lienzo es creato y las im&#xE1;genes son dibujadas dentro de &#xE9;l a trav&#xE9;s de elementos de c&#xF3;digo llamados funciones. Las funciones son el bloque fundamental de un programa en p5.js. El comportamiento de una funci&#xF3;n est&#xE1; definido por sus par&#xE1;metros. Por ejemplo, casi todos los programas en p5.js tienen una funci&#xF3;n createCanvas() que crea un lienzo para dibujar con un ancho y una altura espec&#xED;ficos. Si tu programa no tiene una funci&#xF3;n createCanvas(), el lienzo creado por defecto tiene dimensiones de 100x100 pixeles.
</p>

<h2>Ejemplo 3-1: crea un lienzo</h2>

<p>
La funci&#xF3;n createCanvas() tiene dos par&#xE1;metros, el primero define el ancho del lienzo para dibujar, el segundo define la altura. Para dibujar un lienzo que es de 800 pixeles de ancho y 600 pixeles de altura, escribe:
</p>

<div class="codesplit"><div class="pairs"><div class="pair no-comment"><div class="code">

<pre><code>function setup() {
  createCanvas(800, 600);
}

</code></pre></div></div></div></div>

<p>
Corre esta l&#xED;nea de c&#xF3;digo para ver el resultado. Escribe diferentes valores para explorar las posibilidades. Trata con n&#xFA;meros muy peque&#xF1;os y con n&#xFA;meros m&#xE1;s grandes que las dimensiones de tu pantalla.
</p>

<h2>Ejemplo 3-2: dibuja un punto</h2>

<p>
Para definir el color de un solo pixel dentro del lienzo, usamos la funci&#xF3;n point(). Tiene dos par&#xE1;metros que definen la posici&#xF3;n: la coordenada x, seguida de la coordenada y. Para crear un peque&#xF1;o lienzo y un punto en el centro de &#xE9;l, coordenada (240, 60), escribe:
</p>

<div class="codesplit"><div class="pairs"><div class="pair no-comment"><div class="code">

<pre><code>function setup() {
  createCanvas(480, 120);
}

function draw() {
  background(204);
  point(240, 60);
}

</code></pre></div></div></div></div>

<p>
Escribe un programa que pone un punto en cada esquina del lienzo para dibujar y uno en el centro. Luego trata de poner puntos consecutivos de manera vertical, horizontal y en l&#xED;neas diagonales.
</p>

<h2>Formas b&#xE1;sicas</h2>

<p>
p5.js incluye un grupo de funciones para dibujar formas b&#xE1;sicas (ver la figura 3-1). Formas simples, como l&#xED;neas, pueden ser combinadas para crear formas m&#xE1;s complicadas como una hoja o una cara.
</p>

<p>Para dibujar solo una l&#xED;nea, necesitamos cuatro par&#xE1;metros: dos para el punto de inicio y dos para el final.</p>

<h2>Ejemplo 3-3: dibuja una l&#xED;nea</h2>

<p>Para dibujar una l&#xED;nea entre la coordenada (20, 50) y (420, 110), prueba:</p>

<div class="codesplit"><div class="pairs"><div class="pair no-comment"><div class="code">

<pre><code>function setup() {
  createCanvas(480, 120);
}

function draw() {
  background(204);
  line(20, 50, 420, 110);
}

</code></pre></div></div></div></div>

<h2>Ejemplo 3-4: dibuja formas b&#xE1;sicas</h2>

<p>Siguiendo este patr&#xF3;n, un tri&#xE1;ngulo necesita seis par&#xE1;metros y un cuadril&#xE1;tero necesita ocho (un par para cada punto):</p>

<div class="codesplit"><div class="pairs"><div class="pair no-comment"><div class="code">

<pre><code>function setup() {
  createCanvas(480, 120);
}

function draw() {
  background(204);
  quad(158, 55, 199, 14, 392, 66, 351, 107);
  triangle(347, 54, 392, 9, 392, 66);
  triangle(158, 55, 290, 91, 290, 112);
}

</code></pre></div></div></div></div><script type="text/p5" class="p5 whatever">function setup() {
  createCanvas(480, 120);
}

function draw() {
  background(204);
  quad(158, 55, 199, 14, 392, 66, 351, 107);
  triangle(347, 54, 392, 9, 392, 66);
  triangle(158, 55, 290, 91, 290, 112);
}
</script>
<h2>Ejemplo 3-5: dibuja un rect&#xE1;ngulo</h2>

<p>Tanto rect&#xE1;ngulos como elipses son definidos por cuatro par&#xE1;metros: el primero y el segundo son las coordenadas x e y del punto ancla, el tercero es el ancho y el cuarto por la altura. Para dibujar un rect&#xE1;ngulo (180, 60) con ancho de 220 pixeles y una altura de 40, usa la funci&#xF3;n rect() as&#xED;:</p>

<div class="codesplit"><div class="pairs"><div class="pair no-comment"><div class="code">

<pre><code>function setup() {
  createCanvas(480, 120);
}

function draw() {
  background(204);
  rect(180, 60, 220, 40);
}

</code></pre></div></div></div></div>

<h2>Ejemplo 3-6: dibuja una elipse</h2>

Las coordenadas x e y para un rect&#xE1;ngulo son la esquina superior izquierda, pero para una elipse son el centro de la figura. En este ejemplo, date cuenta que la coordenada y para la primera elipse est&#xE1; fuera del lienzo. Los objetos pueden ser dibujados parcialmente (o enteramente) fuera del lienzo sin arrojar errores:

<div class="codesplit"><div class="pairs"><div class="pair no-comment"><div class="code">

<pre><code>function setup() {
  createCanvas(480, 120);
}

function draw() {
  background(204);
  ellipse(278, -100, 400, 400);
  ellipse(120, 100, 110, 110);
  ellipse(412, 60, 18, 18);
}

</code></pre></div></div></div></div>

<p>p5.js no tiene funciones distintas para hacer cuadrados y c&#xED;rculos. Para hacer estas figuras, usa el mismo valor para los par&#xE1;metros de ancho y altura en las funciones ellipse() y rect().</p>

<h2>Ejemplo 3-7: dibuja una parte de una elipse</h2>

<p>La funci&#xF3;n arc() dibuja una parte de una elipse:</p>

<div class="codesplit"><div class="pairs"><div class="pair no-comment"><div class="code">

<pre><code>function setup() {
  createCanvas(480, 120);
}

function draw() {
  background(204);
  arc(90, 60, 80, 80, 0, HALF_PI);
  arc(190, 60, 80, 80, 0, PI + HALF_PI);
  arc(290, 60, 80, 80, PI, TWO_PI+HALF_PI);
  arc(390, 60, 80, 80, QUARTER_PI, PI+QUARTER_PI);
}

</code></pre></div></div></div></div>

<p>El primer y segundo par&#xE1;metro definen la ubicaci&#xF3;n, mientras que el tercero y el cuarto definen el ancho y la altura. El quinto par&#xE1;metro define el &#xE1;ngulo de inicio y el sexto el &#xE1;ngulo de parada. Los &#xE1;ngulos est&#xE1;n definidos en radianes, en vez de grados. Los radianes son medidas de &#xE1;ngulo basadas en el valor de pi (3.14159). La figura 3-2 muestra c&#xF3;mo ambos est&#xE1;n relacionados. Como se ve en este ejemplo, cuatro valores de radianes son usados tan frecuentemente que fueron agregados con nombres especiales como parte de p5.js. Los valores PI, QUARTER_PI, HALF_PI y TWO_PI pueden ser usados para reemplazar los valores en radianes de 180, 45, 90 y 360 grados.</p>

<h2>Ejemplo 3-8: dibuja con grados</h2>

<p>Si prefieres usar mediciones en grados, puedes convertir a radianes con la funci&#xF3;n radians(). Esta funci&#xF3;n toma un &#xE1;ngulo en grados y lo transforma en su correspondiente valor en radianes. El siguiente ejemplo es el mismo que el ejemplo 3-7, pero usa la funci&#xF3;n radians() para definir en grados los valores de inicio y final:</p>

<div class="codesplit"><div class="pairs"><div class="pair no-comment"><div class="code">

<pre><code>function setup() {
  createCanvas(480, 120);
}

function draw() {
  background(204);
  arc(90, 60, 80, 80, 0, radians(90));
  arc(190, 60, 80, 80, 0, radians(270));
  arc(290, 60, 80, 80, radians(180), radians(450));
  arc(390, 60, 80, 80, radians(45), radians(225));
}

</code></pre></div></div></div></div>

<h2>Ejemplo 3-9: usa angleMode</h2>

<p>Alternativamente, puedes convertir tu bosquejo para que use grados en vez de radianes usando la funci&#xF3;n angleMode(). Esta funci&#xF3;n cambia todas las funciones que aceptan o retornan &#xE1;ngulos para que usen &#xE1;ngulos o radianes, basado en el par&#xE1;metro de al funci&#xF3;n, en vez de que t&#xFA; tengas que convertirlo. El siguiente ejemplo es el mismo que el 3-8, pero usa la funci&#xF3;n angleMode(DEGREES) para definir los valores en grados de inicio y final:</p>

<div class="codesplit"><div class="pairs"><div class="pair no-comment"><div class="code">

<pre><code>function setup() {
  createCanvas(480, 120);
  angleMode(DEGREES);
}

function draw() {
  background(204);
  arc(90, 60, 80, 80, 0, 90);
  arc(190, 60, 80, 80, 0, 270);
  arc(290, 60, 80, 80, 180, 450);
  arc(390, 60, 80, 80, 45, 225);
}

</code></pre></div></div></div></div>

<h2>Orden de dibujo</h2>

<p>Cuando un programa corre, el computador empieza por el principio y lee cada l&#xED;nea de c&#xF3;digo hasta que llega a la &#xFA;ltima l&#xED;nea y luego se detiene.

</p><p>Nota</p>

<p>Hay unas pocas excepciones a esto, como cuando cargas archivos externos, pero revisaremos esto m&#xE1;s adelante. Por ahora, puedes asumir que cada l&#xED;nea correa en orden cuando dibujas.</p>

<p>Si quieres que una figura sea dibujada encima de todas las otras figuras, necesita estar despu&#xE9;s de las otras en el c&#xF3;digo.</p>

<h2>Ejemplo 3-10: controla el orden tu c&#xF3;digo</h2>

<div class="codesplit"><div class="pairs"><div class="pair no-comment"><div class="code">

<pre><code>function setup() {
  createCanvas(480, 120);
}

function draw() {
  background(204);
  ellipse(140, 0, 190, 190);
</code></pre></div></div><div class="pair"><div class="comment"><p>The rectangle draws on top of the ellipse because it comes after in the code</p></div><div class="code">

<pre><code>  rect(160, 30, 260, 20);
}

</code></pre></div></div></div></div>

<h2>Ejemplo 3-11: ponlo en reversa</h2>

<p>Modifica el bosquejo invirtiendo el orden de rect() y ellipse() para ver el c&#xED;rculo encima del rect&#xE1;ngulo:</p>

<div class="codesplit"><div class="pairs"><div class="pair no-comment"><div class="code">

<pre><code>function setup() {
  createCanvas(480, 120);
}

function draw() {
  background(204);
  rect(160, 30, 260, 20);
</code></pre></div></div><div class="pair"><div class="comment"><p>The ellipse draws on top of the rectangle because it comes after in the code</p></div><div class="code">

<pre><code>  ellipse(140, 0, 190, 190);
}

</code></pre></div></div></div></div>

<p>Puedes pensar esto como pintar con brocha o hacer un collage. El &#xFA;ltimo elemento que a&#xF1;ades es el que est&#xE1; visible encima.</p>

<h2>Propiedades de las figuras</h2>

<p>Puedes querer tener m&#xE1;s control de las figuras que dibujas, m&#xE1;s all&#xE1; de su posici&#xF3;n y su tama&#xF1;o. Para lograr esto, existe un conjunto de funcioens que definen las propiedades de las figuras.</p>

<h2>Ejemplo 3-12: define el grosor del trazado</h2>

<p>El valor por defecto del grosor del trazado es de un pixel, pero esto puede ser cambiado con la funci&#xF3;n strokeWeight(). Un solo par&#xE1;metro en la funci&#xF3;n strokeWeight() define el ancho de las l&#xED;neas dibujadas:</p>

<div class="codesplit"><div class="pairs"><div class="pair no-comment"><div class="code">

<pre><code>function setup() {
  createCanvas(480, 120);
}

function draw() {
  background(204);
  ellipse(75, 60, 90, 90);
  strokeWeight(8); //stroke weight to 8 pixels
  ellipse(175, 60, 90, 90);
  ellipse(279, 60, 90, 90);
  strokeWeight(20); //stroke weight to 20 pixels
  ellipse(389, 60, 90, 90);
}

</code></pre></div></div></div></div>

<h2>Ejemplo 3-13: define los atributos del trazado</h2>

<p>La funci&#xF3;n strokeJoin() cambia la forma en que las l&#xED;neas se unen (y c&#xF3;mo se ven las esquinas), y la funci&#xF3;n strokeCap() cambia c&#xF3;mo las l&#xED;neas son dibujadas en su inicio y su final:</p>

<div class="codesplit"><div class="pairs"><div class="pair no-comment"><div class="code">

<pre><code>function setup() {
  createCanvas(480, 120);
}

function draw() {
  background(204);
  strokeJoin(ROUND); // Round the stroke corners
  rect(40, 25, 70, 70);
  strokeJoin(BEVEL); // Bevel the stroke corners
  rect(140, 25, 70, 70);
  strokeCap(SQUARE); // Square the line endings
  line(270, 25, 340, 95);
  strokeCap(ROUND); // Round the line endings
  line(350, 25, 420, 95);
}

</code></pre></div></div></div></div>

<p>La posici&#xF3;n de las figuras como rect() y ellipse() son controladas por las funciones rectMode() y ellipseMode(). Revisa la referencia de p5.js para ver ejemplos de c&#xF3;mo posicionar rect&#xE1;ngulos seg&#xFA;n su centro (en vez de su esquina superior izquierda), o de c&#xF3;mo dibujar elipses desde su esquina superior izquierda como los rect&#xE1;ngulos.</p>

<p>Cuando cualquiera de estos atributos es definido, todas las figuras dibujadas posteriormente son afectadas. Como se ve en el ejemplo 3-12, pon atenci&#xF3;n en c&#xF3;mo el segundo y tercer c&#xED;rculo tienen el mismo grosor de trazado, incluso cuando el grosor es definido solo una vez antes de que ambos sean dibujados.</p>

<p>F&#xED;jate que la l&#xED;nea de c&#xF3;digo strokeWeight(12 aparece en el bloque de setup() en vez de en draw(). Esto es porque no cambia durante la duraci&#xF3;n de nuestro programa, as&#xED; que podemos definirlo s&#xF3;lo una vez durante setup(). Esto es mayoritariamente por organizaci&#xF3;n; poner la l&#xED;nea en draw() tendr&#xED;a el mismo efecto visualizar.</p>

<h2>Color</h2>

<p>Todas las figuras hasta el momento han sido rellenas de color blanco con borde negro. Para cambiar esto, usa las funciones fill() y stroke(). Los valores de los par&#xE1;metros var&#xED;an entre 0 y 255, donde 255 es blanco, 128 es gris medio y 0 es negro. En la figura 3-3 se muestra c&#xF3;mo los valores entre 0 y 255 corresponden a diferentes niveles de gris. La funci&#xF3;n background() que hemos visto en ejemplos anteriores funciona de la misma manera, excepto que en vez de definir el color de relleno o de trazado para dibujar, define el color del fondo del lienzo.</p>

<h2>Ejemplo 3-14: pinta con grises</h2>

<p>Este ejemplo muestra tres diferentes valores de gris en un fondo negro:</p>

<div class="codesplit"><div class="pairs"><div class="pair no-comment"><div class="code">

<pre><code>function setup() {
  createCanvas(480, 120);
}

function draw() {
  background(0);                // Black
  fill(204);                    // Light gray
  ellipse(132, 82, 200, 200);   // Light gray circle
  fill(153);                    // Medium gray
  ellipse(228, -16, 200, 200);  // Medium gray circle
  fill(102);                    // Dark gray
  ellipse(268, 118, 200, 200);  // Dark gray circle
}

</code></pre></div></div></div></div>

<h2>Ejemplo 3-15: controla el relleno y el color del trazado</h2>

<p>Puedes usar la funci&#xF3;n noStroke() para deshabilitar el trazado para que no se dibuje el borde, y puedes deshabilitar el relleno de una figura con noFill():</p>

<div class="codesplit"><div class="pairs"><div class="pair no-comment"><div class="code">

<pre><code>function setup() {
  createCanvas(480, 120);
}

function draw() {
  background(204);
  fill(153);                    // Medium gray
  ellipse(132, 82, 200, 200);   // Gray circle
  noFill();                     // Turn off fill
  ellipse(228, -16, 200, 200);  // Outline circle
  noStroke();                   // Turn off stroke
  ellipse(268, 118, 200, 200);  // Doesn&apos;t draw
}

</code></pre></div></div></div></div>

<p>Ten cuidado de no deshabilitar el relleno y el trazado al mismo tiempo, como lo hicimos en el ejemplo anterior, porque nada ser&#xE1; dibujada en la pantalla.</p>

<h2>Ejemplo 3-16: dibuja con color</h2>

<p>Para ir m&#xE1;s all&#xE1; de la escala de grises, usa tres par&#xE1;metros para espeficar los componentes de color rojo, verde y azul. Como est&#xE1; libro est&#xE1; impreso en blanco y negro, s&#xF3;lo ver&#xE1;s valores grises aqu&#xED;. Corre el c&#xF3;digo para revelar los colores:</p>

<div class="codesplit"><div class="pairs"><div class="pair no-comment"><div class="code">

<pre><code>function setup() {
  createCanvas(480, 120);
}

function draw() {
  background(0, 25, 51);        // Dark blue color
  fill(255, 0, 0);              // Red color
  ellipse(132, 82, 200, 200);   // Red circle
  fill(0, 255, 0);              // Green color
  ellipse(228, -16, 200, 200);  // Green circle
  fill(0, 0, 255);              // Blue color
  ellipse(268, 118, 200, 200);  // Blue circle
}

</code></pre></div></div></div></div>

<p>Los colores en el ejemplo son referidos como color RGB, porque es c&#xF3;mo los computadores definen el color en la pantalla. Los tres n&#xFA;meros definen los valores de rojo, verde y azul, y var&#xED;an entre 0 y 255 de la misma forma que los valores de gris. Estos tres n&#xFA;meros son los par&#xE1;metros para tus funciones de background(), fill() y stroke().</p>

<h2>Ejemplo 3-17: define la transparencia</h2>

<p>Al a&#xF1;adir un cuarto par&#xE1;metro a fill() o a stroke(), puedes controlar la transparencia. Este cuarto par&#xE1;metro es conocido como el valor alpha, y tambi&#xE9;n var&#xED;a entre 0 y 255 para definir el monto de transparencia. El valor 0 define el color como totalmente transparente (no ser&#xE1; mostrado en la pantalla), el valor 255 es enteramente &#xF3;paco, y los valores entre estos extremos hacen que los colores se mezclen en la pantalla:</p>

<div class="codesplit"><div class="pairs"><div class="pair no-comment"><div class="code">

<pre><code>function setup() {
  createCanvas(480, 120);
}

function draw() {
  background(204, 226, 225);    // Light blue color
  fill(255, 0, 0, 160);         // Red color
  ellipse(132, 82, 200, 200);   // Red circle
  fill(0, 255, 0, 160);         // Green color
  ellipse(228, -16, 200, 200);  // Green circle
  fill(0, 0, 255, 160);         // Blue color
  ellipse(268, 118, 200, 200);  // Blue circle
}

</code></pre></div></div></div></div>

<h2>Formas personalizadas</h2>

<p>No est&#xE1;s limitado a usar estas formas geom&#xE9;tricas b&#xE1;sicas - puedes dibujar nuevas formas conectando una serie de puntos.</p>

<h2>Ejemplo 3-18: dibuja una flecha</h2>

<p>La funci&#xF3;n beginShape() se&#xF1;ala el comienzo de una nueva figura. La funci&#xF3;n vertex() es usada para definir cada par de coordenadas (x,y) de la figura. Finalmente, endShape() se&#xF1;ala que la figura est&#xE1; completa:</p>

<div class="codesplit"><div class="pairs"><div class="pair no-comment"><div class="code">

<pre><code>function setup() {
  createCanvas(480, 120);
}

function draw() {
  background(204);
  beginShape();
  vertex(180, 82);
  vertex(207, 36);
  vertex(214, 63);
  vertex(407, 11);
  vertex(412, 30);
  vertex(219, 82);
  vertex(226, 109);
  endShape();
}

</code></pre></div></div></div></div>

<h2>Ejemplo 3-19: cierra la brecha</h2>

<p>Cuando corres el ejemplo 3-18, ver&#xE1;s que el primer y el &#xFA;ltimo punto no est&#xE1;n conectados. Para hacer esto, a&#xF1;ade la palabra CLOSE como par&#xE1;metro a la funci&#xF3;n endShape, as&#xED;:</p>

<div class="codesplit"><div class="pairs"><div class="pair no-comment"><div class="code">

<pre><code>function setup() {
  createCanvas(480, 120);
}

function draw() {
  background(204);
  beginShape();
  vertex(180, 82);
  vertex(207, 36);
  vertex(214, 63);
  vertex(407, 11);
  vertex(412, 30);
  vertex(219, 82);
  vertex(226, 109);
  endShape(CLOSE);
}

</code></pre></div></div></div></div>

<h2>Ejemplo 3-20: crea algunas criaturas</h2>

<p>El poder de definir figuras con vertex() es la habilidad de hacer figuras con bordes complejos. p5.js puede dibujar miles y miles de l&#xED;neas al mismo tiempo para llenar la pantalla con figuras fant&#xE1;sticas que emanan de tu imaginaci&#xF3;n. Un ejemplo modesto pero m&#xE1;s complejo es presentado a continuaci&#xF3;n:</p>

<div class="codesplit"><div class="pairs"><div class="pair no-comment"><div class="code">

<pre><code>function setup() {
  createCanvas(480, 120);
}

function draw() {
  background(204);

</code></pre></div></div><div class="pair"><div class="comment"><p>Left creature</p></div><div class="code">

<pre><code>  beginShape();
  vertex(50, 120);
  vertex(100, 90);
  vertex(110, 60);
  vertex(80, 20);
  vertex(210, 60);
  vertex(160, 80);
  vertex(200, 90);
  vertex(140, 100);
  vertex(130, 120);
  endShape();
  fill(0);
  ellipse(155, 60, 8, 8);
</code></pre></div></div><div class="pair no-comment"><div class="code">

<pre><code>
</code></pre></div></div><div class="pair"><div class="comment"><p>Right creature</p></div><div class="code">

<pre><code>  fill(255);
  beginShape();
  vertex(370, 120);
  vertex(360, 90);
  vertex(290, 80);
  vertex(340, 70);
  vertex(280, 50);
  vertex(420, 10);
  vertex(390, 50);
  vertex(410, 90);
  vertex(460, 120);
  endShape();
  fill(0);
  ellipse(345, 50, 10, 10);
}

</code></pre></div></div></div></div>

<h2>Comentarios</h2>

<p>Los ejemplos en este cap&#xED;tulo usan doble barra (//) al final de una l&#xED;nea para a&#xF1;adir comentarios al c&#xF3;digo. Los comentarios son una parte de los programas que son ignorados cuando el programa corre. Son &#xFA;tiles para hacer notas para ti mismo que expliquen lo que est&#xE1; pasando en el c&#xF3;digo. Si otras personas est&#xE1;n leyendo tu c&#xF3;digo, los comentarios son especialmente importantes para ayudarles a entender tu proceso.</p>

<p>Los comentarios son tambi&#xE9;n especialmente &#xFA;tiles para un n&#xFA;mero de diferentes opciones, como tratar de escoger el color correcto. As&#xED; que, por ejemplo, podr&#xED;amos estar tratando de encontrar el rojo preciso que queremos para una elipse:</p>

<div class="codesplit"><div class="pairs"><div class="pair no-comment"><div class="code">

<pre><code>function setup() {
  createCanvas(200, 200);
}

function draw() {
  background(204);
  fill(165, 57, 57);
  ellipse(100, 100, 80, 80);
}

</code></pre></div></div></div></div>

<p>Ahora sup&#xF3;n que quieres probar un rojo distinto, pero no quieres perder el antiguo. Puedo copiar y pegar la l&#xED;nea, hacer un cambio y luego comentar la l&#xED;nea de c&#xF3;digo antigua:</p>

<div class="codesplit"><div class="pairs"><div class="pair no-comment"><div class="code">

<pre><code>function setup() {
  createCanvas(200, 200);
}

function draw() {
  background(204);
</code></pre></div></div><div class="pair"><div class="comment"><p>fill(165, 57, 57);</p></div><div class="code">

<pre><code>  fill(144, 39, 39);
  ellipse(100, 100, 80, 80);
}

</code></pre></div></div></div></div>

<p>Poner // al principio de una l&#xED;nea temporalmente la anula. O puedo remover // y escribirlo al inicio de otra l&#xED;nea si quiero probarlo de nuevo:</p>

<div class="codesplit"><div class="pairs"><div class="pair no-comment"><div class="code">

<pre><code>function setup() {
  createCanvas(200, 200);
}

function draw() {
  background(204);
  fill(165, 57, 57);
</code></pre></div></div><div class="pair"><div class="comment"><p>(144, 39, 39);</p></div><div class="code">

<pre><code>  ellipse(100, 100, 80, 80);
}

</code></pre></div></div></div></div>

<p>Mientras trabajas con bosquejos de p5.js, te encontrar&#xE1;s a ti mismo creando docenas de iteraciones de ideas; usar comentarios para hacer notas o para deshabilitar l&#xED;neas de c&#xF3;digos puede ayudarte a mantener registro de tus m&#xFA;ltiples opciones.</p>

<h2>Robot 1: dibuja</h2>

<p>Ella es P5, la robot de p5.js. Hay 10 diferentes programas para dibujarla y animarla en este libro - cada uno explora una idea de programaci&#xF3;n diferente. El dise&#xF1;o de P5 est&#xE1; inspirado en Sputnik I (1957), Shakey del Stanford Research Institute (1966 - 1972), el dron luchador en la pel&#xED;cula Dune (1984) de David Lynch y HAL 9000 de 2001: Una odisea en el espacio (1968), entre otros robots favoritos.</p>

<p>El primer programa de robot usa las funciones de dibujo introducidas anteriormente en este cap&#xED;tulo. Los par&#xE1;metros de las funciones fill() y stroke() definen los valores de la escala de grises. Las funciones line(), ellipse() y rect() definen las formas que crean el cuello, las antenas, el cuerpo y la cabeza de la robot. Para familiarizarze mejor con las funciones, corre el programa y cambia los valores para redise&#xF1;ar el robot:</p>

<div class="codesplit"><div class="pairs"><div class="pair no-comment"><div class="code">

<pre><code>function setup() {
  createCanvas(720, 480);
  strokeWeight(2);
  ellipseMode(RADIUS);
}

function draw() {
  background(204);

</code></pre></div></div><div class="pair"><div class="comment"><p>Neck</p></div><div class="code">

<pre><code>  stroke(102);                // Set stroke to gray
  line(266, 257, 266, 162);   // Left
  line(276, 257, 276, 162);   // Middle
  line(286, 257, 286, 162);   // Right
</code></pre></div></div><div class="pair no-comment"><div class="code">

<pre><code>
</code></pre></div></div><div class="pair"><div class="comment"><p>Antennae</p></div><div class="code">

<pre><code>  line(276, 155, 246, 112);   // Small
  line(276, 155, 306,  56);   // Tall
  line(276, 155, 342, 170);   // Medium
</code></pre></div></div><div class="pair no-comment"><div class="code">

<pre><code>
</code></pre></div></div><div class="pair"><div class="comment"><p>Body</p></div><div class="code">

<pre><code>  noStroke();                 // Disable stroke
  fill(102);                  // Set fill to gray
  ellipse(264, 377, 33, 33);  // Antigravity orb
  fill(0);                    // Set fill to black
  rect(219, 257, 90, 120);    // Main body
  fill(102);                  // Set fill to gray
  rect(219, 274, 90, 6);      // Gray stripe
</code></pre></div></div><div class="pair no-comment"><div class="code">

<pre><code>
</code></pre></div></div><div class="pair"><div class="comment"><p>Head</p></div><div class="code">

<pre><code>  fill(0);                    // Set fill to black
  ellipse(276, 155, 45, 45);  // Head
  fill(255);                  // Set fill to white
  ellipse(288, 150, 14, 14);  // Large eye
  fill(0);                    // Set fill to black
  ellipse(288, 150, 3, 3);    // Pupil
  fill(153);                  // Set fill to light gray
  ellipse(263, 148, 5, 5);    // Small eye 1
  ellipse(296, 130, 4, 4);    // Small eye 2
  ellipse(305, 162, 3, 3);    // Small eye 3
}

</code></pre></div></div></div></div>
</section>
<section data-type="chapter" id="capitulo_04_variables">

<h1>Cap&#xED;tulo 4. Variables</h1>

<p>Una variable guarda un valor en memoria para que pueda ser usado posteriormente en un programa. Una variable puede ser usada muchas veces dentro del mismo programa, y el valor puede ser f&#xE1;cilmente modificado mientras el programa est&#xE1; corriendo.</p>

<h2>Primeras variables</h2>

<p>La raz&#xF3;n principal por la que usamos variables es para evitar repetirnos en el c&#xF3;digo. Si est&#xE1;s escribiendo el mismo n&#xFA;mero una y otra vez, considera usar una variable para que tu c&#xF3;digo sea m&#xE1;s general y m&#xE1;s f&#xE1;cil de actualizar.</p>

<h2>Ejemplo 4-1: reusa los mismos valores</h2>

<p>Por ejemplo, cuando haces variables la coordenada y y el di&#xE1;metro para los tres c&#xED;rculos en este ejemplo, los mismos valores son usados para cada elipse:</p>

```
var y = 60;
var d = 80;

function setup() {
  createCanvas(480, 120);
}

function draw() {
  background(204);
  //izquierda
  ellipse(75, y, d, d);
  //centro
  ellipse(175, y, d, d);
  //derecha
  ellipse(275, y, d, d);
}
```

<h2>Ejemplo 4-2: cambiar los valores</h2>

<p>Simplemente cambiar las variables y y d entonces altera las tres elipses:</p>

```
var y = 100;
var d = 130;

function setup() {
  createCanvas(480, 120);
}

function draw() {
  background(204);
  //izquierda
  ellipse(75, y, d, d);
  //centro
  ellipse(175, y, d, d);
  //derecha
  ellipse(275, y, d, d);
}
```

Sin las variables, necesitar&#xED;as cambiar la coordenada y usada en el c&#xF3;digo tres veces y la del di&#xE1;metro seis veces. Cuando comparas los ejemplos 4-1 y 4-2, revisa c&#xF3;mo todas las l&#xED;neas son iguales, excepto las dos primeras l&#xED;neas con variables que son diferentes. Las variables te permiten separar las l&#xED;neas de c&#xF3;digo que cambian de las que no cambian, lo que hace que los programas sean f&#xE1;ciles de modificar. Por ejemplo, si pones las variables que controlan colores y tama&#xF1;os en un lugar, entonces puedes explorar diferentes opciones visuales enfoc&#xE1;ndote en s&#xF3;lo unas pocas l&#xED;neas de c&#xF3;digo.

<h2>Haciendo variables</h2>

<p>Cuando haces tus propias variables, puedes determinar el nombre y el valor. T&#xFA; decides c&#xF3;mo se llama la variable. Escoge un nombre que sea informativo sobre lo que est&#xE1; almacenado en la variable, pero que sea consistente y no muy largo. Por ejemplo, el nombre de variable &quot;radio&quot; es mucho m&#xE1;s claro que &quot;r&quot; cuando lo lees posteriormente en tu c&#xF3;digo.</p>

<p>Las variables primero deben ser declaradas, lo que reserva espacio en la memoria del computador para guardar la informaci&#xF3;n. Cuando declaras una variable, usas la palabra var, para indicar que est&#xE1;s creando una nueva variable, seguida del nombre. Despu&#xE9;s de que el nombre es fijado, un valor puede ser asignado a la variable:</p>

```
var x;  // Declara la variable x
x = 12; // Asigna un valor a x
```

Este c&#xF3;digo hace lo mismo, pero es m&#xE1;s corto:

```
var x = 12;  // Declara la variable x y le asigna un valor
```

<p>Los caracteres var son incluidos en la l&#xED;nea de c&#xF3;digo que declara la variable, pero no son escritos de nuevo. Cada vez que var es escrito antes que el nombre de una variable, el computador piensa que est&#xE1;s tratando de declarara una nueva variable. No puedes tener dos variables con el mismo nombre en la misma secci&#xF3;n del programa (Ap&#xE9;ndice C), o el programa podr&#xED;a comportarse extra&#xF1;amente:</p>

```
var x;      // Declara la variable x
var x = 12; // ERROR! No pueden haber dos variables x
```
Puedes situar tus variables afuera de setup() y draw(). Si creas una variable dentro de setup(), no puedes usarla dentro de draw(), as&#xED; que necesitas situar estas variables en otro lugar. Estas variables reciben el nombre de variables globales, porque pueden ser usadas en cualquier lugar (&quot;globalmente&quot;) del programa.

<h2>Variables de p5.js</h2>

<p>p5.js tiene una serie de variables especiales para almacenar informaci&#xF3;n sobre el programa mientras corre. Por ejemplo, el ancho y la altura del lienzo est&#xE1;n almacenados en las variables width y height. Estos valores son definidos por la funci&#xF3;n createCanvas(). Pueden ser usados para dibujar elementos relativos al tama&#xF1;o del lienzo, incluso si la l&#xED;nea de c&#xF3;digo de createCanvas() es alterada.</p>

<h2>Ejemplo 4-3: ajusta el lienzo, observa lo que sucede</h2>

<p>En este ejemplo, cambia los par&#xE1;metros de createCanvas() para observar c&#xF3;mo funciona:</p>

```
function setup() {
  createCanvas(480, 120);
}

function draw() {
  background(204);
  line(0, 0, width, height); // L&#xED;nea desde (0,0) a (480, 120)
  line(width, 0, 0, height); // L&#xED;nea desde (480,0) a (0, 120)
  ellipse(width/2, height/2, 60, 60);
}
```

<p>Existen tambi&#xE9;n variables epsciales que mantienen registro del estado del rat&#xF3;n y de los valores del teclado, entre otras. Ser&#xE1;n discutidas en el Cap&#xED;tulo 5.</p>

<h2>Un poco de matem&#xE1;ticas</h2>

<p>La gente a menudo asume que las matem&#xE1;ticas y la programaci&#xF3;n son lo mismo. Aunque un poco de conocimiento de matem&#xE1;ticas puede ser &#xFA;til para ciertos tipos de programaci&#xF3;n, la aritm&#xE9;tica b&#xE1;sica cubre las partes m&#xE1;s importantes.</p>

<h2>Ejemplo 4-4: aritm&#xE9;tica b&#xE1;sica</h2>

```

var x = 25;
var h = 20;
var y = 25;

function setup() {
  createCanvas(480, 120);
}

function draw() {
  background(204);
  x = 20;
  rect(x,y,300,h);          // Superior
  x = x + 100;
  rect(x, y + h, 300, h);   // Centro
  x = x - 250;
  rect(x, y + h*2, 300, h); // Inferior
}
```
<p>En el c&#xF3;digo, s&#xED;mbolos como +, - y * son llamados operadores. Cuando se encuentran entre dos valores, crean una expresi&#xF3;n. Por ejemplo, 5 + 9 y 1024 - 512 son expresiones. Los operadores para operaciones matem&#xE1;ticas b&#xE1;sicas son:</p>

<p>Javascript tiene un conjunto de reglas para definir el orden de precedencia que los operadores tienen entre s&#xED;, lo que significa, cu&#xE1;les c&#xE1;lculos son efectuados en primer, segundo y tercer lugar, etc. Estas reglas definen el orden en el que el c&#xF3;digo se ejecuta. Un poco de conocimiento sobre esto es un gran paso hacia el entendimiendo de c&#xF3;mo funciona una corta l&#xED;nea de c&#xF3;digo como esta:</p>

```
var x = 4 + 4 * 5;  // Se le asigna el valor 24 a x
```

<p>La expresi&#xF3;n 4*5 es evaluada primero porque la multiplicaci&#xF3;n tiene la prioridad m&#xE1;s alta. Luego, se le suma 4 al producto 4*5, resultando 24. Finalmente, como el operador de asignaci&#xF3;n (el signo igual) tiene la menor predecencia, el valor 24 es asignado a la variable x. Esto se puede aclarar con el uso de par&#xE9;ntesis, pero el resultado es el mismo:</p>

```
var x = 4 + (4 * 5);  // Se le asigna el valor 24 a x
```

<p>Si quieres forzar que la suma ocurra primero, usa par&#xE9;ntesis. Como los par&#xE9;ntesis tienen mayor precedencia que la multiplicaci&#xF3;n, al cambiar los par&#xE9;ntesis de lugar se cambia el c&#xE1;lculo efectuado:</p>

```
var x = 4 + (4 * 5);  // Se le asigna el valor 24 a x
```

<p>Un acr&#xF3;nimo para este orden se ense&#xF1;a en clases de matem&#xE1;ticas: PEMDAS, que significa par&#xE9;ntesis, exponentes, multiplicaci&#xF3;n, divisi&#xF3;n, adici&#xF3;n, substracci&#xF3;n, donde los par&#xE9;ntesis tienen la mayor prioridad y la substracci&#xF3;n la menor. El orden completo de operaciones se encuentra anotado en el Ap&#xE9;ndice B.</p>

<p>Algunos c&#xE1;lculos son usados tan frecuentemente en programaci&#xF3;n que se han desarrollado atajos, es &#xFA;til ahorrar tiempo en el teclado. Por ejemplo, cuando puedes sumar o restar a una variable con un operador:</p>

```
x += 10;  // Es equivalente a x = x + 10;
x -= 15;  // Es equivalente a x = x - 15;
```

<p>Tambi&#xE9;n es muy com&#xFA;n sumar o restar 1 a una variable, as&#xED; que esto tambi&#xE9;n tiene un atajo. Los operadores ++ y -- hacen esto:</p>

```
x ++;  // Es equivalente a x = x + 1;
x --;  // Es equivalente a x = x - 1;
```

<h2>Repetici&#xF3;n</h2>

<p>Mientras escribes programas, te dar&#xE1;s cuenta que ocurren patrones al repetir l&#xED;neas de c&#xF3;digo con peque&#xF1;as modificaciones. Una estructura de c&#xF3;digo llamada &quot;for loop&quot; hace posible que una l&#xED;nea de c&#xF3;digo corre m&#xE1;s de una vez para condensar el tipo de repetici&#xF3;n a unas pocas l&#xED;neas de c&#xF3;digo. Esto hace que tus programas sean modulares y m&#xE1;s simples de modificar.</p>

<h2>Ejemplo 4-5: haz lo mismo una y otra vez</h2>

<p>Este ejemplo tiene el tipo de patr&#xF3;n que puede ser simplificado con un &quot;for loop&quot;:</p>

```
function setup() {
  createCanvas(480, 120);
  strokeWeight(8);
}

function draw() {
  background(204);
  line( 20, 40,  80, 80);
  line( 80, 40, 140, 80);
  line(140, 40, 200, 80);
  line(200, 40, 260, 80);
  line(260, 40, 320, 80);
  line(320, 40, 380, 80);
  line(380, 40, 440, 80);
}
```

<h2>Ejemplo 4-6: usa un for loop</h2>

<p>Lo mismo puede ser logrado con un for loop, y con mucho menos c&#xF3;digo:</p>

```
function setup() {
  createCanvas(480, 120);
  strokeWeight(8);
}

function draw() {
  background(204);
  for (var i = 20; i &lt; 400; i += 60) {
    line( i, 40,  i + 60, 80);
  }
}
```

<p>El for loop es diferente en muchas maneras del c&#xF3;digo que hemos escrito hasta ahora. F&#xED;jate en las llaves, los caracteres { y }. El c&#xF3;digo repetido entre las llaves es llamado bloque. Este es el c&#xF3;digo que ser&#xE1; repetido en cada iteraci&#xF3;n del for loop.</p>

<p>Adentro del par&#xE9;ntesis hay tres declaraciones, separadas por punto y coma, que funcionan en conjunto para controlar cu&#xE1;ntas veces el c&#xF3;digo dentro del bloque es ejecutado. De izquierda a derecha, estas declaraciones son nombradas as&#xED;: inicializaci&#xF3;n (init), prueba (test), actualizaci&#xF3;n (update):</p>

```
for (init; test; update) {
  declaraciones
}
```
<p>Init t&#xED;picamente declara una variable nueva a ser usada en el for loop y le asigna un valor. El nombre de variable i es frecuentemente usado, pero esto no tiene nada de especial. El test eval&#xFA;a el valor de esta variable, y update change el valor de la variable. La figura 4-1 muestra el orden en el que el c&#xF3;digo es ejectuado y c&#xF3;mo controlan el c&#xF3;digo dentro del bloque.</p>

<p>La prueba o test requiere m&#xE1;s explicaci&#xF3;n. Siempre es una expresi&#xF3;n de relaci&#xF3;n que compara dos valores con un operador relacional. En este ejemplo, la expresi&#xF3;n es &quot;i &lt; 400&quot; y el operador es el s&#xED;mbolo &lt; (menor que). Los operadores relacionales m&#xE1;s comunes son:</p>

<p>La expresi&#xF3;n relacional siempre evalua a verdadero (true) o falso (false). Por ejemplo, la expresi&#xF3;n 5 &gt; 3 es true. Podemos preguntar, &quot;&#xBF;es cinco mayor que tres?&quot;. Como la respuesta es &quot;s&#xED;&quot;, decimos que la expresi&#xF3;n es true. Para la expresi&#xF3;n 5 &lt; 3, podemos preguntar, &quot;&#xBF;es cinco menor que tres?&quot;. Como la respuesta es no, decimos que la expresi&#xF3;n es false. Cuando la evaluaci&#xF3;n es true, el c&#xF3;digo dentro del bloque se ejecuta y cuando es false, el c&#xF3;digo dentro del bloque no se ejecuta y el for loop se acaba.</p>

<h2>Ejemplo 4-7: entrena tus m&#xFA;sculos para hacer for loops</h2>

<p>El poder definitivo que entregan los for loop es la habilidad para hacer cambios r&#xE1;pidos a tu c&#xF3;digo. Como el c&#xF3;digo dentro del bloque es ejecutado t&#xED;picamente m&#xFA;ltiples veces, un cambio al bloque es magnificado cuando el c&#xF3;digo es ejecutado. Al modificar el ejemplo 4-6 un poco, podemos crear una variedad de distintos patrones:</p>

```
function setup() {
  createCanvas(480, 120);
  strokeWeight(2);
}

function draw() {
  background(204);
  for (var i = 20; i &lt; 400; i += 8) {
    line( i, 40,  i + 60, 80);
  }
}
```

<h2>Ejemplo 4-8: desplegando las l&#xED;neas</h2>

```
function setup() {
  createCanvas(480, 120);
  strokeWeight(2);
}

function draw() {
  background(204);
  for (var i = 20; i &lt; 400; i += 20) {
    line( i, 0,  i + i/2, 80);
  }
}
```

<h2>Ejemplo 4-9: modificando las l&#xED;neas</h2>

```
function setup() {
  createCanvas(480, 120);
  strokeWeight(2);
}

function draw() {
  background(204);
  for (var i = 20; i &lt; 400; i += 20) {
    line( i, 0,  i + i/2, 80);
    line( i + i/2,  80, i * 1.2, 80);
  }
}
```

<h2>Ejemplo 4-10: anidando un for loop dentro de otro</h2>

<p>Cuando un for loop es anidado dentro de otro, el n&#xFA;mero de repeticiones se multiplica. Primero veamos un ejemplo corto y luego lo veremos por partes en el ejemplo 4-11.</p>

```
function setup() {
  createCanvas(480, 120);
  noStroke();
}

function draw() {
  background(0);
  for (var y = 0; y <= height;="" y="" +="40)" {="" for="" (var="" x="0;" <="width;" fill(255,="" 140);="" ellipse(x,="" y,="" 40,="" 40);="" }="" ```="" <h2="">Ejemplo 4-11: filas y columnas

<p>En este ejemplo, los for loops est&#xE1;n adyacentes, en vez de estar uno dentro de otro. El resultado muestra que un for loop est&#xE1; dibujando una columna de 4 c&#xED;rculos y el otro est&#xE1; dibujando una fila de 13 c&#xED;rculos.</p>

```
function setup() {
  createCanvas(480, 120);
  noStroke();
}

function draw() {
  background(0);
  for (var y = 0; y &lt; height + 45; y += 40) {
    fill(255, 140);
    ellipse(0, y, 40, 40);
  }
  for (var x = 0; x <= width="" +="" 45;="" x="" {="" fill(255,="" 140);="" ellipse(x,="" 0,="" 40,="" 40);="" }="" ```="" <p="">Cuando uno de estos for loop es puesto dentro del otro, como en el ejemplo 4-10, las 4 repeticiones del primer loop son compuestas con las 13 del segundo, para as&#xED; ejecutar el c&#xF3;digo dentro del bloque compuesta 52 veces (4 x 13 = 52).<p></p>

<p>El ejemplo 4-10 es una buena base para explorar muchos tipos de patrones visuales repetitivos. Los siguientes ejemplos muestran un par de maneras en que esto puede ser extendido, pero esto es solo una peque&#xF1;a muestra de lo que es posible.</p>

<h2>Ejemplo 4-12: alfileres y l&#xED;neas</h2>

<p>En este ejemplo, el c&#xF3;digo dibuja una l&#xED;nea desde cada punto de la matriz hasta el centro de la pantalla:</p>

```
function setup() {
  createCanvas(480, 120);
  fill(255);
  stroke(102);
}

function draw() {
  background(0);
  for (var y = 20; y &lt; height - 20; y += 10) {
    for (var x = 20; x <= width="" -="" 20;="" x="" +="10)" {="" ellipse(x,="" y,="" 4,="" 4);="" dibuja="" una="" línea="" al="" centro="" de="" la="" imagen="" line(x,="" 240,="" 60);="" }="" ```="" <h2="">Ejemplo 4-13: Puntos semitono

<p>En este ejemplo, las elipses se reducen en tama&#xF1;o con cada nueva fila y son movidas hacia la derecha, por medio de a&#xF1;adir la coordenada y a la coordenada x:</p>

```
function setup() {
  createCanvas(480, 120);
}

function draw() {
  background(0);
  for (var y = 32; y &lt; height; y += 8) {
    for (var x = 12; x <= 16="" width;="" x="" +="15)" {="" ellipse(x="" y,="" -="" y="" 10.0,="" 10.0);="" }="" ```="" <h2="">Robot 2: variables

<p>Las variables introducidas en este programa hacen que el c&#xF3;digo se vea m&#xE1;s dif&#xED;cil que el de la Robot 1 (ver &quot;Robot 1: dibuja&quot;), pero ahora es mucho m&#xE1;s simple hacer modificaciones, porque los n&#xFA;meros que dependen uno de otro est&#xE1;n en una misma ubicaci&#xF3;n. Por ejemplo, el dibujo del cuello est&#xE1; basado en la variable neckHeight. El grupo de variables al principio del c&#xF3;digo controla los aspectos del robot que queremos cambiar: ubicaci&#xF3;n, altura del cuerpo y altura del cuello. Puedes observar algunas de las posibles variaciones posibles en la figura; de izquierda a derecha, ac&#xE1; est&#xE1;n los valores correspondientes:</p>

<p>Cuando alteras tu propio c&#xF3;digo para usar variables en vez de n&#xFA;meros, planea los cambios cuidadosamente y despu&#xE9;s haz las modificaciones en pasos cortos. Por ejemplo, cuando este programa fue escrito, cada variable fue creada de a una a la vez para minimizar la complejidad de la transici&#xF3;n. Solo despu&#xE9;s de que una variable era creada y el c&#xF3;digo era ejecutado para asegurarse de que funcionara correctamente, se a&#xF1;ad&#xED;a una siguiente variable:</p>

```
var x = 60;                                      // Coordenada X
var y = 420;                                    // Coordenada Y
var bodyHeight = 110;                           // Altura del cuerpo
var neckHeight = 140;                           // Altura del cuello
var radius = 45;
var ny = y - bodyHeight - neckHeight - radius;  // Y del cuello

function setup(){
  createCanvas(170, 480);
  strokeWeight(2);
  ellipseMode(RADIUS);
}

function draw() {
  background(204);

  // Cuello
  stroke(102);
  line(x +  2, y - bodyHeight, x +  2, ny);
  line(x + 12, y - bodyHeight, x + 12, ny);
  line(x + 22, y - bodyHeight, x + 22, ny);

  // Antenas
  line(x + 12, ny, x - 18, ny - 43);
  line(x + 12, ny, x + 42, ny - 99);
  line(x + 12, ny, x + 78, ny + 15);

  // Cuerpo
  noStroke();
  fill(102);
  ellipse(x, y - 33, 33, 33);
  fill(0);
  rect(x - 45, y - bodyHeight, 90, bodyHeight - 33);
  fill(102);
  rect(x - 45, y - bodyHeight + 17, 90, 6);

  // Cabeza
  fill(0);
  ellipse(x + 12, ny, radius, radius);
  fill(255);
  ellipse(x + 24, ny - 6, 14, 14);
  fill(0);
  ellipse(x + 24, ny - 6, 3, 3);
  fill(153);
  ellipse(x, ny - 8, 5, 5);
  ellipse(x + 30, ny - 26, 4, 4);
  ellipse(x + 41, ny + 6, 3, 3);
}

```

</=></=></=></=></section>

<section data-type="chapter" id="capitulo_07_medios">

<h1>Cap&#xED;tulo 5. Respuesta</h1>

El c&#xF3;digo que responde a acciones de entrada del rat&#xF3;n, teclado u otros dispositivos  depende en que el programa corra continuamente. Ya nos enfrentamos a las funciones setup() y draw() en el Cap&#xED;tulo 1. Ahora aprenderemos m&#xE1;s sobre qu&#xE9; hacen y c&#xF3;mo usarlas para reaccionar a entradas al programa.

## Una vez y para siempre

El c&#xF3;digo dentro del bloque draw() corre desde el principio al final, luego se repite hasta que cierras el programa cuando cierras la ventana. Cada iteraci&#xF3;n a trav&#xE9;s del bloque draw() es llamado un cuadro o frame. (La tasa de cuadros por defecto es de 60 cuadros por segundo, pero esto puede ser modificado).

## Ejemplo 5-1: la funci&#xF3;n draw()

Para observar como la funci&#xF3;n draw() funciona, corre este ejemplo:

```
function draw() {
  //Muestra en la consola el contador de cuadros
  print(&quot;Estoy dibujando&quot;);
  print(frameCount);
}
```
Ver&#xE1;s lo siguiente:

```
Estoy dibujando
1
Estoy dibujando
2
Estoy dibujando
3
...
```

En el ejemplo anterior, las funciones print() escriben el texto &quot;Estoy dibujando&quot; seguido del contador actual de cuadros, tarea efectuada por la variable especial frameCount. El texto aparece en la consola de tu navegador.

## Ejemplo 5-2: la funci&#xF3;n setup()

Para complementar la repetitiva funci&#xF3;n draw(), p5.js posee la funci&#xF3;n setup() que solo corre una vez cuando el programa empieza:

```
function setup() {
  print(&quot;Estoy empezando&quot;);
}

function draw() {
  print(&quot;Estoy corriendo&quot;);
}
```

Cuando corres el c&#xF3;digo, en la consola se escribe lo siguiente:

```
Estoy empezando
Estoy corriendo
Estoy corriendo
Estoy corriendo
...
```

El texto &quot;Estoy corriend&quot; sigue escribi&#xE9;ndose en la consola hasta que el programa es parado.

En algunos navegadores, en vez de escribir una y otra vez &quot;Estoy corriendo&quot;, lo imprimir&#xE1; solo una vez, y despu&#xE9;s para cada subsecuente vez, incrementar&#xE1; un n&#xFA;mero junto a la l&#xED;nea, representando el n&#xFA;mero total de veces que la l&#xED;nea ha sido impresa de corrido.

En un programa t&#xED;pico, el c&#xF3;digo dentro de setup() es usado para definir las condiciones iniciales. La primera l&#xED;nea es usualmente la funci&#xF3;n createCanvas(), a menudo seguida de c&#xF3;digo para definir los colores de relleno y trazado iniciales. (Si no incluyes la funci&#xF3;n createCanvas(), el lienzo para dibujar tendr&#xE1; una dimensi&#xF3;n de 100x100 pixeles por defecto).

Ahora sabes c&#xF3;mo usar setup() y draw() en mayor detalle, pero esto no es todo.

Hay una ubicaci&#xF3;n adicional d&#xF3;nde has estado poniendo c&#xF3;digo - tambi&#xE9;n puedes poner variables globales fuera de setup() y draw(). Esto se hace m&#xE1;s claro cuando listamos el orden en que el c&#xF3;digo es ejecutado.

1. Las variables declaradas fuera de setup() y draw() son creadas.

2. El c&#xF3;digo dentro de setup() es ejecutado una vez.

3. El c&#xF3;digo dentro de draw() corre continuamente.

## Ejemplo 5-3: setup(), te presento a draw()

El siguiente ejemplo pone en pr&#xE1;ctica todos estos conceptos:

```
var x = 280;
var y = -100;
var diameter = 380;

function setup() {
  createCanvas(480, 120);
  fill(102);
}

function draw() {
  background(204);
  ellipse(x, y, diameter, diameter);
}
```

## Seguir

Como el c&#xF3;digo est&#xE1; corriendo continuamente, podemos seguir la posici&#xF3;n del rat&#xF3;n y usar estos n&#xFA;meros para mover elementos en la pantalla.

## Ejemplo 5-4: seguir al rat&#xF3;n

La variable mouseX graba la coordenada x, y la variable mouseY graba la coordenada y:

```
function setup() {
  createCanvas(480, 120);
  fill(0, 102);
  noStroke();
}

function draw() {
  ellipse(mouseX, mouseY, 9, 9);
}
```
En este ejemplo, cada vez que el c&#xF3;digo en el bloque draw() es ejecutado, un nuevo c&#xED;rculo es a&#xF1;adido al lienzo. La imagen fue hecha moviendo el rat&#xF3;n para controlar la posici&#xF3;n del c&#xED;rculo. Como la funci&#xF3;n de relleno est&#xE1; definida para ser parcialmente transparente, las &#xE1;reas negras m&#xE1;s densas muestran d&#xF3;nde el rat&#xF3;n estuvo m&#xE1;s tiempo o se movi&#xF3; m&#xE1;s lento. Los c&#xED;rculos que est&#xE1;n m&#xE1;s separados muestran d&#xF3;nde el rat&#xF3;n estuvo movi&#xE9;ndose m&#xE1;s r&#xE1;pido.

## Ejemplo 5-5: el punto te persigue

En este ejemplo, un nuevo c&#xED;rculo es a&#xF1;adido al lienzo cada vez que el c&#xF3;digo dentro de draw() es ejecutado. Para refrescar la pantalla y sollo mostrar el c&#xED;rculo m&#xE1;s reciente, escribe la funci&#xF3;n background() al principio del bloque draw() antes que la figura sea dibujada:

```
function setup() {
  createCanvas(480, 120);
  fill(0, 102);
  noStroke();
}

function draw() {
  background(204);
  ellipse(mouseX, mouseY, 9, 9);
}
```
La funci&#xF3;n background() pinta el lienzo completo , as&#xED; que aseg&#xFA;rate de ponerlo antes que las otras funciones dentro de draw(). Si no haces esto, las figuras dibujadas antes ser&#xE1;n borradas.

## Ejemplo 5-6: dibuja de forma continua

Las variables pmouseX y pmouseY guardan la posici&#xF3;n del rat&#xF3;n en el cuadro anterior. Como mouseX y mouseY, estas variables especiales son actualizadas cada vez que draw() es ejecutado. Cuando las combinas, pueden ser usadas para dibujar l&#xED;neas continuas al conectar las posiciones actual y m&#xE1;s reciente:

```
function setup() {
  createCanvas(480, 120);
  strokeWeight(4);
  stroke(0, 102);
}

function draw() {
  line(mouseX, mouseY, pmouseX, pmouseY);
}
```

## Ejemplo 5-7: define el grosor sobre la marcha

Las variables pmouseX y pmouseY tambi&#xE9;n pueden ser usadas para calcualr la velocidad del rat&#xF3;n. Esto se hace midiendo la distancia entre la posici&#xF3;n actual y la m&#xE1;s reciente del rat&#xF3;n. Si el rat&#xF3;n se est&#xE1; moviendo lentamente, la distancia es peque&#xF1;a, pero si se empieza a mover m&#xE1;s r&#xE1;pido, la distancia se incrementa. Una funci&#xF3;n llamada dist() simplifica este c&#xE1;lculo, como se muestra en el siguiente ejemplo. Aqu&#xED;, la velocidad del rat&#xF3;n es usada para definir el grosor de la l&#xED;nea dibujada

```
function setup() {
  createCanvas(480, 120);
  stroke(0, 102);
}

function draw() {
  var weight = dist(mouseX, mouseY, pMouseX, pMouseY);
  strokeWeight(weight);
  line(mouseX, mouseY, pmouseX, pmouseY);
}
```
## Ejemplo 5-8: el suavizado lo hace

En el ejemplo 5-7, los valores del rat&#xF3;n son convertidos directamente a posiciones en la pantalla. Pero a veces queremos que estos valores sigan al rat&#xF3;n m&#xE1;s libremente - que se queden atr&#xE1;s para creen un movimiento m&#xE1;s fluido. Esta t&#xE9;cnica es llamada suavizado. Con el suavizado, hay dos valores: el valor actual y el valor objetivo (ver Figura 5-1). A cada paso en el programa, el valor actual se mueve un poco m&#xE1;s cerca del valor objetivo:

```
var x = 0;
var easing = 0.01;

function setup() {
  createCanvas(220, 120);
}

function draw() {
  var targetX = mouseX;
  x += (targetX - x) * easing;
  ellipse(x, 40, 12, 12);
  print(targetX + &quot; : &quot; + x);
}

```

El valor de la variable x est&#xE1; siempre acerc&#xE1;ndose a targetX. La velocidad con la que lo alcanzo es definida por la variable de easing, un n&#xFA;mero entre 0 y 1. Un valor peque&#xF1;o de easing causa m&#xE1;s retraso que un valor m&#xE1;s grande. Con un valor de easing de 1, no hay retraso. Cuando corres el ejemplo 5-8, los valores actuales son mostrados en la consola a trav&#xE9;s de la funci&#xF3;n print(). Cuando muevas el mouse, observa c&#xF3;mo los n&#xFA;meros est&#xE1;n alejados, pero cuando dejas de moverlo, el valor de x se acerca al valor de targetX.

Todo el trabajo en este ejemplo ocurre en la l&#xED;nea que empieza con x+=. Aqu&#xED;, se calcula la diferencia entre el valor objetivo y el actual, y luego es multiplicada por la variable easing y a&#xF1;adida a x para llevarla m&#xE1;s cerca que el objetivo.

## Ejemplo 5-9: suaviza las l&#xED;neas

En este ejemplo, la t&#xE9;cnica de suavizado es aplicada al Ejemplo 5-7. En comparaci&#xF3;n, las l&#xED;neas son m&#xE1;s fluidas:

```
var x = 0;
var y = 0;
var px = 0;
var py = 0;
function setup() {
  createCanvas(480, 120);
  stroke(0, 102);
}

function draw() {
  var targetX = mouseX;
  x += (targetX - x) * easing;
  var targetY = mouseY;
  y += (targetY - y) * easing;
  var weight = dist(x,y,px,py);
  strokeWeight(weight);
  line(x,y,px,py);
  py = y;
  px = x;
}
```
## Click

Adem&#xE1;s de la ubicaci&#xF3;n del rat&#xF3;n, p5.js tambi&#xE9;n mantiene registro de si el bot&#xF3;n del rat&#xF3;n ha sido presionado o no. La variable mouseIsPressed tiene un valor diferente cuando el bot&#xF3;n del rat&#xF3;n est&#xE1; presionado. La variable mouseIsPressed es una variable boolean, lo que significa que solo tiene dos posibles valores: verdadero (true) o falso (falso). El valor de mouseIsPressed es verdadero cuando un bot&#xF3;n es presionado.

## Ejemplo 5-10: haz click con el rat&#xF3;n

La variable mouseIsPressed es usada en conjunto con la declaraci&#xF3;n if para determinar si una l&#xED;nea de c&#xF3;digo ser&#xE1; ejecutada o no. Prueba este ejemplo antes de sigamos explicado:

```
function setup() {
  createCanvas(240, 120);
  strokeWeight(30);
}

function draw() {
  background(204);
  stroke(102);
  line(40, 0, 70, height);
  if (mouseIsPressed == true) {
    stroke(0);
  }
  line(0,70,width,50);
}
```
En este programa, el c&#xF3;digo dentro del blocke if s&#xF3;lo corre cuando el bot&#xF3;n del rat&#xF3;n es presionado. Cuando el bot&#xF3;n no est&#xE1; presionado, el c&#xF3;digo es ignorado. Como el for loop discutido en &quot;Repetition&quot;, el bloque if tiene una prueba (test) que es evaluada a verdadero (true) o falso (false).

```
if (test) {
  statements
}
```

Cuando el test es true, el c&#xF3;digo dentro del bloque es ejecutado y cuando es falso, no es ejecutado. El computador determina si el test es true o false al evaluar la expresi&#xF3;n dentro del par&#xE9;ntesis. (Si quieres refrescar tu memoria, el ejemplo 4-6 discute en mayor detalle expresiones relacionales). El s&#xED;mbolo == compara los valores a la izquierda y la derecha para probar si son equivalentes o no. El s&#xED;mbolo == es diferente del operador de asignaci&#xF3;n, el s&#xED;mbolo unitario =. el s&#xED;mbolo == pregunta, &quot;&#xBF;son estas cosas iguales?&quot;, mientras que el s&#xED;mbolo = define el valor de una variable

## Nota

Es un error com&#xFA;n, incluso para programadores avanzados, escribir = en el c&#xF3;digo en vez de ==. p5.js no siempre te advertir&#xE1; cu&#xE1;ndo lo hagas, as&#xED; que s&#xE9; cuidadoso.

Alternativamente, la prueba en draw() puede ser escrita as&#xED;:

```
if (mouseIsPressed) {
```

Las variables Boolean, incluyendo a mouseIsPressed, no necesitan la comparaci&#xF3;n expl&#xED;cita con el operador ==, porque su valor es solo o true o false.

## Ejemplo 5-11: detecci&#xF3;n de no clickeado

Un bloque if te da la oportunidad de correr una porci&#xF3;n de c&#xF3;digo o de ignorarla. Puedes extender la funcionalidad del bloque if con el bloque else, permitiendo que tu programa escoja entre dos opciones. El c&#xF3;digo dentro del bloque else corre cuando el valor de la prueba del bloque if es false. Por ejemplo, el color de trazado de un programa puede ser negro cuando el bot&#xF3;n del rat&#xF3;n no es presionado y puede cambiar a negro cuando s&#xED; es presionado:

```
function setup() {
  createCanvas(240, 120);
  strokeWeight(30);
}
function draw() {
  background(204);
  stroke(102);
  line(40, 0, 70, height);
  if (mouseIsPressed) {
    stroke(0);
  } else {
    stroke(255);
  }
  line(0, 70, width, 50);
}
```
## Ejemplo 5-12: M&#xFA;ltiples botones del rat&#xF3;n

p5.js tambi&#xE9;n registra cu&#xE1;l bot&#xF3;n del rat&#xF3;n es presionado si es que tienes m&#xE1;s de uno en tu rat&#xF3;n. La variable mouseButton puede tener uno de estos tres valores: LEFT, CENTER o RIGHT. Para probar cu&#xE1;l de los botones es presionado, el operador == es necesario, como se muestra a continuaci&#xF3;n:

```
function setup() {
  createCanvas(120, 120);
  strokeWeight(30);
}

function draw() {
  background(204);
  stroke(102);
  line(40, 0, 70, height);
  if (mouseIsPressed) {
    if (mouseButton == LEFT) {
      stroke(255);
    } else {
      stroke(0);
    }
    line(0,70,width,50);
  }
}
```

Un programa puede tener muchas m&#xE1;s estructuras if y else (ver Figura 5-2) que las encontradas en estos ejemplos cortos. Pueden ser concatenadas en una larga serie con distintas pruebas, y los bloques if pueden estar anidados dentro de otros bloques if para hacer decisiones m&#xE1;s complejas.

## Ubicaci&#xF3;n

Una estructura if puede ser usada con los valores de mouseX y mouseY para determinar la ubicaci&#xF3;n del cursos dentro de la ventana.

## Ejemplo 5-13: encuentra el cursos

En este ejemplo, buscamos el cursor para ver si est&#xE1; a la izquierda o hacia la derecha de la l&#xED;nea y luego movemos la l&#xED;nea hacia el cursor:

```
var x;
var offset = 10;

function setup() {
  createCanvas(240, 120);
  x = width/2;
}

function draw() {
  background(204);
  if (mouseX &gt; x) {
    x += 0.5;
    offset = -10;
  }
  if (mouseX &lt; x) {
    x -= 0.5;
    offset = 10;
  }
  //dibuja una flecha izquierda o derecha seg&#xFA;n el valor del &quot;offset&quot;
  line(x, 0, x, height);
  line(mouseX, mouseY, mouseX + offset    , mouseY - 10);
  line(mouseX, mouseY, mouseX + offset    , mouseY + 10);
  line(mouseX, mouseY, mouseX + offset * 3, mouseY);
}
```

Para escribir programas que tengan interfaces gr&#xE1;ficas de usuario (botones, casillas, barras deslizadoras, etc.) necesitamos escribir c&#xF3;digo que sepa cuando el curso est&#xE1; dentro de un &#xE1;rea de la pantalla. Los siguientes dos ejemplos introducen c&#xF3;mo verificar si el cursor est&#xE1; dentro de un c&#xED;rculo y de un rect&#xE1;ngulo. El c&#xF3;digo est&#xE1; escrito en una forma modular variables, para que pueda ser usado para comprobar con cualquier c&#xED;rculo o rect&#xE1;ngulo mediante la modificaci&#xF3;n de los valores.

## Ejemplo 5-14: los bordes de un c&#xED;rculo

Para la prueba con el c&#xED;rculo, usamos la funci&#xF3;n dist() para obtener la distancia desde el centro del c&#xED;rculo al cursor, luego probamos si este valor es menor que el radio del c&#xED;rculo (ver Figura 5-3). Si lo es, sabemos que estamos dentro del c&#xED;rculo. En este ejemplo, cuando el cursos est&#xE1; denrro del &#xE1;rea del c&#xED;rcuo, su tama&#xF1;o aumenta:

```
var x = 120;
var y = 60;
var radius = 12;

function setup() {
  createCanvas(240, 120);
  ellipseMode(RADIUS);
}

function draw() {
  background(204);
  var d = dist(mouseX, mouseY, x, y);
  if (d &lt; radius) {
    radius++;
    fill(0);
  } else {
    fill(255);
  }
  ellipse(x, y, radius, radius);
}
```

## Ejemplo 5-15: Los bordes de un rect&#xE1;ngulo

Usaremos otro enfoque para probar si el curso est&#xE1; dentro de un rect&#xE1;ngulo. Hacemos cuatro pruebas separadas para comprobar si el cursor est&#xE1; en el lado correcto de cada uno de los lados del rect&#xE1;ngulo, luego comparamos cada resultado de las pruebas y si todas son true, entonces sabemos que el cursor est&#xE1; dentro. Esto es ilustrado en la Figura 5-4. Cada paso es simple, pero lucen complicados al combinarse entre s&#xED;:

```
var x = 80;
var y = 30;
var w = 80;
var h = 60;

function setup() {
  createCanvas(240, 120);
}

function draw() {
  background(204);
  if ((mouseX &gt; x) &amp;&amp; (mouseX &lt; x+w) &amp;&amp;
      (mouseY &gt; y) &amp;&amp; (mouseY &lt; y+h)) {
        fill(0);
      } else {
        fill(255);
      }
      rect(x, y, w, h);
}
```

La prueba en la declaraci&#xF3;n if es un poco m&#xE1;s complicada que lo que hemos visto hasta el momento. Cuatro pruebas individuales (como mouseX &gt; x) son combinadas con el operador l&#xF3;gico AND, el s&#xED;mbolo &amp;&amp;, para asegurarse que cada expresi&#xF3;n relacional en la secuencia sea true. Si alguna de ellas es false, el test entero es false y el color de relleno no ser&#xE1; negro.

## Tipo

p5.js mantiene registro de cualquier tecla que sea presionada en el teclado, adem&#xE1;s de la &#xFA;ltima tecla presionada. Tal como la variable mouseIsPressed, la variable keyIsPressed is true cuando cualquier tecla es presionada, y false cuando no hay teclas presionadas.

## Ejemplo 5-16: presiona una tecla

En este ejemplo, la segunda l&#xED;nea es dibujada solo cuando hay una tecla presionada:

```
function setup() {
  createCanvas(240, 120);
}

function draw() {
  background(204);
  line(20, 20, 220, 100);
  if (keyIsPressed) {
    line(220, 20, 20, 100);
  }
}
```

La variable key guarda la tecla presionada m&#xE1;s recientemente. A diferencia de la variable boolean keyIsPressed, que se revierte a false cada vez que la tecla es soltada, la variable key mantiene su valor hasta que la siguiente tecla es presionada. El siguiente ejemplo usa el valor de key para dibujar el caracter en la pantalla. Cada vez qeu una nueva tecla es presionada, el valor se actualiza y un nuevo caracter es dibujado. Algunas teclas, como Shift y Alt, no tienen un caracter visible, as&#xED; que si las presionas, nada ser&#xE1; dibujado.

## Ejemplo 5-17: dibuja algunas letras

Este ejemplo introduce la funci&#xF3;n textSize() para definir el tama&#xF1;o de las letras, la funci&#xF3;n textAlign() para centrar el texto en su coordenada x y la funci&#xF3;n text() para dibujar la letra. Estas funciones ser&#xE1;n discutidas en mayor detalle en &quot;Fonts&quot;.

```
function setup{
  createCanvas(120,120);
  textSize(64);
  textAlign(CENTER);
  fill(255);
}

function draw() {
  background(0);
  text(key, 60, 80);
}
```
Usando una estructura if, podemos probar si una tecla espec&#xED;fica es presionad y escoger dibujar algo distinto en la pantalla a modo de respuesta.

## Ejemplo 5-18: revisar diferentes teclas

En este ejemplo, revisamos si las teclas N o H son presionadas. Usamos el comparador de comparaci&#xF3;n, el s&#xED;mbolo ==, para revisar si el valor de la variable key es igual a los caracteres que estamos buscando:

```
function setup() {
  createCanvas(120, 120);
}

function draw() {
  background(204);
  if (keyIsPressed) {
    if ((key == &apos;h&apos;) || (key == &apos;H&apos;)) {
      line(30, 60, 90, 60);
    }
    if ((key == &apos;n&apos;) || (key == &apos;N&apos;)) {
      line(30, 20, 90, 100);
    }
  }
  line(30, 20, 30, 100);
  line(90, 20, 90, 100);
}
```
Cuando revisamos si est&#xE1; siendo presionada la tecla H o la N, necesitamos revisar tanto para las letras en may&#xFA;scula como en min&#xFA;scula, en caso de que alguien presione la tecla Shift o tenga la funci&#xF3;n Caps Lock activada. Combinamos ambas pruebas con el operador l&#xF3;gico OR, el s&#xED;mbolo ||. Si traducimos la segunda declaraci&#xF3;n if en este ejemplo a lenguaje plano, dice &quot;Si la tecla &apos;h&apos; es presionada OR la tecla &apos;H&apos; es presionada&quot;. A diferencia del operador l&#xF3;gico AND (el s&#xED;mbolo &amp;&amp;), solo una de estas expresiones necesita ser true para que la prueba entera sea evaluada a true.

Algunas teclas son m&#xE1;s dif&#xED;ciles de detectar, porque no est&#xE1;n asociadas a una letra en particular. Teclas como Shift, Alt, y las flechas est&#xE1;n codificadas. Tenemos que revisar el c&#xF3;digo con la variable keyCode para revisar qu&#xE9; tecla es. Los valores m&#xE1;s frecuentes de keyCode son ALT, CONTROL y SHIFT, adem&#xE1;s de las teclas con flechas UP_ARROW, DOWN_ARROW, LEFT_ARROW Y RIGHT_ARROW.

## Ejemplo 5-19: mover con las flechas

El siguiente ejemplo muestra c&#xF3;mo usar las flechas izquierda y derecha para mover un rect&#xE1;ngulo.

```
var x = 215;
function setup() {
  createCanvas(480, 120);
}

function draw() {
  if (keyIsPressed) {
    if (keyCode == LEFT_ARROW) {
      x--;
    } else if (keyCode == RIGHT_ARROW) {
      x++;
    }
  }
  rect(x, 45, 50, 50);
}
```
## Toque

Para dispositivos que lo soportan, p5.js mantiene registr de si la pantalla es tocada y su ubicaci&#xF3;n. Como la variable mouseIsPressed, la variable touchIsdown es true cuando la pantalla es tocada, y false cuando no.

## Ejemplo 5-20: toca la pantalla

En este ejemplo, la segunda l&#xED;nea es dibujada solo si la pantalla es tocada

```
function setup() {
  createCanvas(240, 120);
}

function draw() {
  background(204);
  line(220, 20, 220, 100);
  if (touchIsdown) {
    line(220, 20, 20, 100);
  }
}
```
Como las variables mouseX y mouseY, las variables touchX y touchY almacenan las coordenadas x e y del punto donde la pantalla est&#xE1; siendo tocada.

## Ejemplo 5-21: rastrea el dedo

En este ejemplo, un nuevo c&#xED;rculo es a&#xF1;adido al lienzo cada vez que el c&#xF3;digo en draw() es ejecutado. Para refrescar la pantalla y solo mostrar el c&#xED;rculo m&#xE1;s nuevo, escribe la funci&#xF3;n background() al inicio de draw() antes de dibujar la figura:

```
function setup() {
  createCanvas(480, 120);
  fill(0, 102);
  noStroke();
}

function draw() {
  ellipse(touchX, touchY, 15, 15);
}
```

## Mapeo

Los n&#xFA;meros que son creados por el rat&#xF3;n y por el teclado muchas veces necesitan ser modificados para ser &#xFA;tiles dentro del programa. Por ejemplo, si un bosquejo tiene un ancho de 1920 pixeles y los valores de mouseX son usados para definir el color del fondo, el rango de 0 a 1920 de mouseX necesitar&#xE1; ser escalado para moverse en un rango de 0 a 255 para controlar mejor el color. Esta transformaci&#xF3;n puede ser hecha con una ecuaci&#xF3;n o con una funci&#xF3;n llamada map().

## Ejemplo 5-22: mapeo de valores a un rango

En este ejemplo, la ubicaci&#xF3;n de dos l&#xED;neas es controlada por la variable mouseX. La l&#xED;nea gris est&#xE1; sincronizada con la posici&#xF3;n del cursor, pero la l&#xED;nea negra se mantiene m&#xE1;s cerca del centro de la pantalla y se aleja de la l&#xED;nea blanca en los bordes izquierdos y derechos.

```
function setup() {
  createCanvas(240, 120);
  strokeWeight(12);
}

function draw() {
  background(204);
  stroke(102);
  line(mouseX, 0, mouseX, height);  // L&#xED;nea gris
  stroke(0);
  var mx = mouseX/2 + 60;
  line(mx, 0, mx, height);          // L&#xED;nea negra
}
```

La funci&#xF3;n map() es una manera m&#xE1;s general de hacer este tipo de cambio. Convierte una variable desde un rango de valores a otro. El primer par&#xE1;metro es la variable a ser convertida, el segundo y tercer valor son los valores m&#xED;nimo y m&#xE1;ximo de esa variable, y el cuarto y quinto son los valores m&#xED;nimo y m&#xE1;ximo deseados. La funci&#xF3;n map() esconde la matem&#xE1;tica detr&#xE1;s de esta conversi&#xF3;n.

## Ejemplo 5-23: Mapeo con la funci&#xF3;n map()

Este ejemplpo reescribe el Ejemplo 5-22 usando map():

```
function setup() {
  createCanvas(240, 120);
  strokeWeight(12);
}

function draw() {
  background(204);
  stroke(255);
  line(120, 60, mouseX, mouseY);  // L&#xED;nea blanca
  stroke(0);
  var mx = map(mouseX, 0, width, 60, 180);
  line(120, 60, mx, mouseY);      // L&#xED;nea negra
}
```

La funci&#xF3;n map() hace que el c&#xF3;digo sea f&#xE1;cil de leer, porque los valores m&#xE1;ximo y m&#xED;nimo est&#xE1;n claramente escritos como par&#xE1;metros. En este ejemplo, los valores de mouseX entre 0 y width son convertidos a n&#xFA;meros entre 60 (cuando mouseX es 0) y 180 (cuando mouseX es width). Encontrar&#xE1;s esta &#xFA;til funci&#xF3;n map() en muchos ejemplos a lo largo de este libro.

## Robot 3: respuesta

Este programa usa las variables introducidas en Robot 2 (ver &quot;Robot 2: variables&quot;) y hace posible cambiarlas mientras el programa corre de manera que las figuras respondan al rat&#xF3;n. El c&#xF3;digo dentro del bloque draw() es ejecutado muchas veces por segundo. En cada cuadro, las variables definidas en el programa cambian en respuesta a las variables mouseX y mouseIsPressed.

La variable mouseX controla la posici&#xF3;n del robot con la t&#xE9;cnica de suavizado para que los movimientos sean menos instant&#xE1;neos y se vean m&#xE1;s naturales. Cuando un bot&#xF3;n del rat&#xF3;n es presionado, los valores de neckHeight y bodyHeight cambian para hacer al robot m&#xE1;s corto:

```
var x = 60;           // Coordenada x
var y = 440;          // Coordenada y
var radius = 45;      // Radio de la cabeza
var bodyHeight = 160; // Altura del cuerpo
var neckHeight = 70;  // Altura del cuello

var easing = 0.04;

function setup() {
  createCanvas(360, 480);
  strokeWeight(2);
  ellipseMode(RADIUS);
}

function draw() {
  var targetX = mouseX;
  x += (targetX - x) * easing;
  if (mouseIsPressed) {
    neckHeight = 16;
    bodyHeight = 90;
  } else {
    neckHeight = 70;
    bodyHeight = 160;
  }

  var neckY = y - bodyHeight - neckHeight - radius;

  background(204);

  // Cuello
  stroke(102);
  line(x + 12, y - bodyHeight, x + 12, neckY);

  // Antenas
  line(x + 12, neckY, x - 18, neckY - 43);
  line(x + 12, neckY, x + 42, neckY - 99);
  line(x + 12, neckY, x + 78, neckY + 15);

  // Cuello
  noStroke();
  fill(102);
  ellipse(x, y - 33, 33, 33);
  fill(0);
  rect(x - 45, y - bodyHeight, 90, bodyHeight - 33);

  // Cabeza
  fill(0);
  ellipse(x + 12, neckY, radius, radius);
  fill(255);
  ellipse(x + 24, neckY - 6, 14, 14);
  fill(0);
  ellipse(x + 24, neckY - 6, 3, 3);
}
```
</section>

<section data-type="chapter" id="capitulo_06_trasladar">

<h1>Cap&#xED;tulo 6. Trasladar, rotar, escalar</h1>

Una t&#xE9;cnica alternativa para posicionar y mover objetos en la pantalla es cambiar el sistema de coordenadas de la pantalla. Por ejemplo, puedes mover una figura 50 pixeles a la derecha, o puedes mover la ubicaci&#xF3;n de la coordenada (0,0) 50 pixeles a la derecha - el resultado visual en la pantalla es el mismo.

Al modificar el sistema de coordenadas por defecto, podemos crear diferentes transformaciones incluyendo traslaci&#xF3;n, rotaci&#xF3;n y escalamiento.

## Traslaci&#xF3;n

Trabajar con transformaciones puede ser dif&#xED;cil, pero la funci&#xF3;n translate() es la m&#xE1;s sencilla, as&#xED; que empezaremos con esta. Como muestra la Figura 6-1, esta funci&#xF3;n puede cambiar el sistema de coordenadas hacia la izquierda, derecha, arriba y abajo.

## Ejemplo 6-1: trasladando la ubicaci&#xF3;n

En este ejemplo, observa que el rect&#xE1;ngulo est&#xE1; dibujado en la coordenada (0,0), pero est&#xE1; en otra posici&#xF3;n en el lienzo, porque es afectado por la funci&#xF3;n translate():

```
function setup() {
  createCanvas(120, 120);
  background(204);
}

function draw() {
  translate(mouseX, mouseY);
  rect(0, 0, 30, 30);
}
```

La funci&#xF3;n translate() define la coordenada (0,0) de la pantalla a la ubicaci&#xF3;n del rat&#xF3;n (mouseX y mouseY). Cada vez que el bloque draw() se repite, el rect&#xE1;ngulo es dibujado en el nuevo origen, derivado de la posici&#xF3;n actual del rat&#xF3;n.

## Ejemplo 6-2: m&#xFA;ltiples traslados

Despu&#xE9;s de que la transformaci&#xF3;n es realizada, es aplicada a todas las veces que la funci&#xF3;n draw() es ejecutada. Observa lo que pasa cuando una segunda funci&#xF3;n translate() es a&#xF1;adida para controlar un segundo rect&#xE1;ngulo:

```
function setup() {
  createCanvas(120, 120);
  background(204);
}

function draw() {
  translate(mouseX, mouseY);
  rect(0, 0, 30, 30);
  translate(35, 10);
  rect(0, 0, 15, 15);
}
```
Los valores para la funci&#xF3;n translate() son acumulados. El peque&#xF1;o rect&#xE1;ngulo es trasladado seg&#xFA;n mouseX + 35 0,0y mouseY + 10. Las coordenadas x e y para ambos rect&#xE1;ngulos son (0,0), pero las funciones translate() los mueven a otras posiciones en el lienzo.
Sin embargo, incluso cuando las transformaciones se acumulan dentro del bloque draw(), se reinician cada vez que la funci&#xF3;n draw() empieza de nuevo.

## Rotaci&#xF3;n
La funci&#xF3;n rotate() rota el sistema de coordenadas. Tiene un par&#xE1;metro, que es el &#xE1;ngulo (en radianes) a rotar. Siempre rota relativo a (0,0), lo que se conoce como rotar en torno al origen. La Figura 3-2 muestra los valores de &#xE1;ngulo en radianes. La figura 6-2 muestra la diferencia entre rotar con n&#xFA;meros positivos y negativos.

## Ejemplo 6-3: rotaci&#xF3;n de la esquina

Para rotar una figura, primero define el &#xE1;ngulo de rotaci&#xF3;n con rotate(), luego dibuja la figura. En este bosquejo, el par&#xE1;metro para rotar (mouseX / 100.0) tendr&#xE1; un valor entre 0 y 1.2 para definir el &#xE1;ngulo de rotaci&#xF3;n porque mouseX tendr&#xE1; un valor entre 0 y 120, el ancho del lienzo seg&#xFA;n lo definido en createCanvas():

```
function setup() {
  createCanvas(120, 120);
  background(204);
}

function draw() {
  rotate(mouseX / 100.0);
  rect(40, 30, 160, 20);
}
```

## Ejemplo 6-4: rotaci&#xF3;n del centro

Para rotar una figura en torno a su propio centro, deben ser dibujada con la coordenada (0,0) en su centro. En este ejemplo, como la figura tiene un ancho de 160 y una altura de 20 seg&#xFA;n lo definido en la funci&#xF3;n rect(), es dibujada en la coordenada (-80, -10) para poner la coordenada (0,0) al centro de la figura:

```
function setup() {
  createCanvas(120, 120);
  background(204);
}

function draw() {
  rotate(mouseX / 100.0);
  rect(-80, -10, 160, 20);
}
```

El par anterior de ejemplos muestra c&#xF3;mo rotar alrededor de un sistema de coordenadas (0,0), &#xBF;pero qu&#xE9; otras posibilidades hay? Puedes usar las funciones translate() y rotate() para mayor control. Cuando son combinadas, el orden en que aparecen afecta el resultado. Si el sistema de coordenadas es trasladado y despu&#xE9;s rotado, es diferente que primero rotar y despu&#xE9;s mover el sistema de coordenadas.

## Ejemplo 6-5: traslaci&#xF3;n, despu&#xE9;s rotaci&#xF3;n

Para girar una figura en torno a su centro a un lugar en la pantalla lejos del orgien, primero usa la funci&#xF3;n traslate() para mover la figura a la ubicaci&#xF3;n donde quieres la figura, luego usa rotate(), y luego dibuja la figura con su centro en la coordenada (0,0):

```
var angle = 0.0;

function setup() {
  createCanvas(120, 120);
  background(204);
}

function draw() {
  translate(mouseX, mouseY);
  rotate(angle);
  rect(-15, -15, 30, 30);
  angle += 0.1;
}
```

## Ejemplo 6-6: rotaci&#xF3;n, despu&#xE9;s traslaci&#xF3;n

El siguiente ejemplo es id&#xE9;ntico al Ejemplo 6-5, excepto que translate() y rotate() ocurren en el orden inverso. La figura ahora rota alrededor de la esquina superior izquierda, con la distancia desde la esquina definida por translate():

```
var angle = 0.0;

function setup() {
  createCanvas(120, 120);
  background(204);
}

function draw() {
  rotate(angle);
  translate(mouseX, mouseY);
  rect(-15, -15, 30, 30);
  angle += 0.1;
}
```

## Nota

Puedes usar tambi&#xE9;n las funciones rectMode(), ellipseMode() y imageMode() hacen m&#xE1;s simple dibujar figuras desde su centro. Puedes leer sobre estas funciones en la Referencia de p5.js.

## Ejemplo 6-7: un brazo articulado

En este ejemplo, hemos puesto juntas una serie de funciones translate() y rotate() para crear un brazo articulado. Cada funci&#xF3;n translate() mueve la posici&#xF3;n de las l&#xED;neas, y cada funci&#xF3;n rotate() a&#xF1;ade a la rotaci&#xF3;n previa para doblar m&#xE1;s:

```
var angle = 0.0;
var angleDirection = 1;
var speed = 0.005;

function setup() {
  createCanvas(120, 120);
}

function draw() {
  background(204);
  translate(20, 25);  // Mover a la posici&#xF3;n inicial
  rotate(angle);
  strokeWeight(12);
  line(0, 0, 40, 0);
  translate(40, 0);   // Mover la siguiente articulaci&#xF3;n
  rotate(angle * 2.0);
  strokeWeight(6);
  line(0, 0, 30, 0);
  translate(30, 0);
  rotate(angle * 2.5);
  strokeWeight(3);
  line(0, 0, 20, 0);

  angle += speed * angleDirection;
  if ((angle &gt; QUARTER_PI) || (angle &lt; 0)) {
    angleDirection *= -1;
  }
}
```

La variable angle crece desde 0 hasta QUARTER_PI (un cuarto del valor de pi), luego decae hasta que es menor que cero, luego el ciclo se repite. El valor de la variable angleDirection est&#xE1; siempre entre 1 y -1 para hacer que el valor de angle correspondiente crezca o decrezca.

## Escalar

La funci&#xF3;n scale() estira las coordenadas del lienzo. Como las coordenadas se expanden o se contraen cuando cambia la escala, todo lo que est&#xE1; dibujado en el lienzo aumenta o disminuye sus dimensiones. El monto de escalamiento est&#xE1; escrito en porcentajes decimales. Entonces, el par&#xE1;metro 1.5 en la funci&#xF3;n scale() resulta en un 150% y 3 es 300% (Figura 6-3).

## Ejemplo 6-8: escalamiento

Como rotate(), la funci&#xF3;n scale() transforma desde el origen. Entonces, tal como rotate(), para escalar una figura desde su centro, debemos trasladar su ubicaci&#xF3;n, escalar y luego dibujar con el centro en la coordenada (0,0):

```
function setup() {
  createCanvas(120, 120);
  background(204);
}

function draw() {
  translate(mouseX, mouseY);
  scale(mouseYX / 60.0);
  rect(-15, -15, 30, 30);
}
```

## Ejemplo 6-9: manteniendo los trazos constantes

De las l&#xED;neas gruesas del Ejemplo 6-8, puedes ver c&#xF3;mo la funci&#xF3;n scale() afecta el grosor del trazado. Para mantener un grosor de trazado consistente a medida que la figura se escala, divide el trazado deeseado por el valor escalar:

```
function setup() {
  createCanvas(120, 120);
  background(204);
}

function draw() {
  translate(mouseX, mouseY);
  var scalar = mouseX / 60.0;
  scale(scalar);
  strokeWeight(1.0 / scalar);
  rect(-15, -15, 30, 30);
}
```

## Push y pop

Para aislar los efectos de la transformaci&#xF3;n para que no afecten otras funciones, usa las funciones push() y pop(). When ejecutas push(), graba una copia del sistema de coordenadas actual y luego restaura ese sistema cuando ejecutas pop(). Esto es &#xFA;til cuando las transformaciones son necesarias para una figura, pero no son deseadas para otras.

## Ejemplo 6-10: aislando transformaciones

En este ejemplo, el rect&#xE1;ngulo peque&#xF1;o siempre dibuja en la misma pop():

```
function setup() {
  createCanvas(120, 120);
  background(204);
}

function draw() {
  push();
  translate(mouseX, mouseY);
  rect(0, 0, 30, 30);
  pop();
  translate(35, 10);
  rect(0, 0, 15, 15);
}
```

## Nota

Las funciones push() y pop() siempre se usan en pares. Por cada push(), tiene que haber un correspondiente pop().

## Robot 4: trasladar, rotar, escalar

Las funciones translate(), rotate() y scale() son utilizadas para modificar el bosquejo del robot. En relaci&#xF3;n al ejemplo Robot 3: respuesta, translate() es usado para hacer el c&#xF3;digo m&#xE1;s f&#xE1;cil de leer. Aqu&#xED;, observa c&#xF3;mo ya no es necesario el valor de x a cada funci&#xF3;n de dibujo porque la funci&#xF3;n translate() mueve todo. Similarmente, la funci&#xF3;n scale() es usada para definir las dimensiones para todo el robot. Cuando el rat&#xF3;n no est&#xE1; presionado, el tama&#xF1;o es de un 60% y cuando s&#xED; est&#xE1; presionado, es de un 100% en relaci&#xF3;n a las coordenadas originales. La funci&#xF3;n rotate() es usada dentro del loop para dibujar una l&#xED;nea, rotarla un poco, luego dibujar una segunda l&#xED;nea, luego rotarla un poco m&#xE1;s, y as&#xED; hasta que el loop ha dibujado 30 l&#xED;neas en forma de c&#xED;rculo para estilizar el pelo de la cabeza del robot:

```
var x = 60;           // Coordenada x
var y = 440;          // Coordenada y
var radius = 45;      // Radio de la cabeza
var bodyHeight = 180; // Altura del cuerpo
var neckHeight = 40;  // Altura del cuello

var easing = 0.04;

function setup() {
  createCanvas(360, 480);
  strokeWeight(2);
  ellipseMode(RADIUS);
}

function draw() {
  var neckY = -1 * (bodyHeight + neckHeight + radius);

  background(204);

  translate(mouseX, y); // Mueve todo a (mouseX, y)

  if (mouseIsPressed) {
    scale(1.0);
  } else {
    scale(0.6);       // 60% de tama&#xF1;o si el rat&#xF3;n est&#xE1; presionado
  }

  // Cuerpo

  noStroke();
  fill(102);
  ellipse(0, -33, 33, 33);
  fill(0);
  rect(-45, -bodyHeight, 90, bodyHeight - 33);

  // Cuello
  stroke(102);
  line(12, -bodyHeight, 12, neckY);

  // Pelo
  push();
  translate(12, neckY);
  var angle = -PI/30.0;
  for (var i = 0l i <= 30;="" i++)="" {="" line(80,="" 0,="" 0);="" rotate(angle);="" }="" pop();="" cabeza="" nostroke();="" fill(0);="" ellipse(12,="" necky,="" radius,="" radius);="" fill(255);="" ellipse(24,="" necky="" -="" 6,="" 14,="" 14);="" 3,="" 3);="" ```="" <="" section="">
</=></section>
<section data-type="chapter" id="capitulo_07_medios">

<h1>Cap&#xED;tulo 7. Medios</h1>

<p>p5.js es capaz de dibujar m&#xE1;s que simplemente l&#xED;neas y figuras. Es tiempo de aprender c&#xF3;mo crear im&#xE1;genes y texto en nuestros programas para extener las posibilidades visuales a fotograf&#xED;a, diagramas detallados y diversas tipograf&#xED;as.</p>

<p>Antes de que hagamos esto, primero tenemos que hablar un poco sobre servidores. Hasta este punto, hemos estado viendo el archivo index.html directamente en el navegador. Esto funciona bien para correr animaciones simples. Sin embargo, si quieres hacer cosas como cargar una imagen externa en tu bosquejo, tu navegador no lo va a permitir. Si revisas la consola, te encontrar&#xE1;s con un error conteniendo el t&#xE9;rmino &quot;cross-origin&quot;. Para cargar archivos externos, tienes que correr un servidor. Un servidor es un programa que funciona como un manejador de capas. Responde cuando escribes una URL en la barra de direcciones, y sirve los archivos correspondientes a ti para su visualizaci&#xF3;n.</p>

<p>Existen diferentes maneras de correr servidores. Visita https://github.com/processing/p5.js/wiki/Local-server para ver las instrucciones de c&#xF3;mo correr un servidor en sistemas Mac OS X, Windows y Linux. Una vez que lo tengas configurado, &#xA1;est&#xE1;s listo para cargar media!</p>

<p>Hemos subido algunos archivos para que los uses en los ejemplos de este cap&#xED;tulo: http://p5js.org/learn/books/media.zip.</p>

<p>Descarga este archivo, descompr&#xED;melo en tu escritorio (o en otro lugar conveniente) y anota su ubicaci&#xF3;n.</p>

<h2>Nota</h2>

<p>Para descomprimir en Mac OS X, basta con hacer doble click en el archivo y se crear&#xE1; un directorio llamado media. En Windows, haz doble click en el archivo media.zip, el que abrir&#xE1; una nueva ventana. En esa ventana, arrastra el directorio llamado media al escritorio.</p>

<p>Crea un nuevo bosquejo, y copia el archivo lunar.jpg desde el directorio media que acabas de descomprimir al directorio de tu bosquejo.</p>

## Nota

<p>En Windows y Mac OS X, las extensiones de los archivos est&#xE1;n escondidas por defecto. Es una buena idea cambiar esta opci&#xF3;n para que siempre veas el nombre completo de tus archivos. En Mac OS X, selecciona Preferencias desde el men&#xFA; principal, y luego aseg&#xFA;rate que &quot;Mostrar la extensi&#xF3;n completa&quot; est&#xE9; seleccionado en la pesta&#xF1;a de opciones avanzadas. En Windows, busca las Opciones de Directorio, y selecciona la opci&#xF3;n ah&#xED;.</p>


## Im&#xE1;genes

<p>Estos son los tres pasos que tienes que seguir antes de que puedas dibujar una imagen en la pantalla:</p>

1. A&#xF1;ade la imagen al directorio del bosquejo

2. Crea una variable para almacenar la imagen.

3. Carga la imagen a la variable con la funci&#xF3;n loadImage().

## Ejemplo 7-1: carga una imagen

<p>Para cargar una imagen, introduciremos una nueva funci&#xF3;n llamada preload(). La funci&#xF3;n preload() corre una vez y antes de que la funci&#xF3;n setup() corra. Generalmente deber&#xED;as cargar tus imagenes y otros archivos dentro de preload() para asegurarte que est&#xE9;n completamente cargadas antes de que tu programa empiece a correr. Discutiremos esto en mayor profundidad m&#xE1;s adelante en el cap&#xED;tulo.</p>

<p>Despu&#xE9;s de que los tres pasos son completados, puedes dibujar la imagen en la pantalla con la funci&#xF3;n image(). El primer par&#xE1;metro de image() especifica la imagen a dibujar, el segundo y tercero son las coordenadas x e y:</p>

```
var img;

function preload() {
  img = loadImage(&quot;lunar.jpg&quot;);
}

function setup() {
  createCanvas(480, 120);
}

function draw() {
  image(img, 0, 0);
}
```

<p>Los par&#xE1;metros opcionales cuarto y quinto determinan el ancho y altura de la imagen a dibujar. Si no se usan los par&#xE1;metros cuarto y quinto, la imagen es dibujada al tama&#xF1;o original que fue creada.</p>

<p>Los siguientes ejemplos muestran c&#xF3;mo trabajar con m&#xE1;s de una imagen en el mismo programa y c&#xF3;mo escalar la imagen.</p>

## Ejemplo 7-2: carga m&#xE1;s im&#xE1;genes

<p>Para este ejemplo, necesitar&#xE1;s agregar el archivo capsule.jpg (que est&#xE1; dentro del directorio media que descargaste) al directorio de tu bosquejo.</p>

```
var img1;
var img2;

function preload() {
  img1 = loadImage(&quot;lunar.jpg&quot;);
  img2 = loadImage(&quot;capsule.jpg&quot;);
}

function setup() {
  createCanvas(480, 120);
}

function draw() {
  image(img1, -120, 0);
  image(img1, 130, 0, 240, 120);
  image(img2, 300, 0, 240, 120);
}
```
## Ejemplo 7-3: mover las im&#xE1;genes con el rat&#xF3;n

<p>Cuando las variables mouseX y mouseY son usadas como los par&#xE1;metros cuarto y quinto de la funci&#xF3;n image(), el tama&#xF1;o de la imagen cambia con el movimiento del rat&#xF3;n:</p>

```javascript
var img;

function preload() {
  img = loadImage(&quot;lunar.jpg&quot;);
}

function setup() {
  createCanvas(480, 120);
}

function draw() {
  background(0);
  image(img, 0, 0, mouseX * 2, mouseY * 2);
}
```

## Nota

<p>Cuando una imagen es mostrada m&#xE1;s grande o peque&#xF1;a que su tama&#xF1;o original, puede aparecer distorsionada. Ten cuidado en preparar tus im&#xE1;genes a los tama&#xF1;os en que ser&#xE1;n usadas. Cuando el tama&#xF1;o de la imagen es cambiado con la funci&#xF3;n image(), el archivo original en tu directorio del bosquejo no cambia.</p>

<p>p5.js puede cargar y mostrar im&#xE1;genes raster en los formatos JPEG, PNG y GIF, adem&#xE1;s de im&#xE1;genes vector en el formato SVG. Puedes convertir im&#xE1;genes a los formatos JPEG, PNG, GIF y SVG usando programas como GIMP, Photoshop e Illustrator. La mayor parte de las c&#xE1;maras digitales graban sus im&#xE1;genes en el formato JPEG, pero usualmente necesitan ser reducidas en tama&#xF1;o para ser usadas con p5.js. Una c&#xE1;mara digital t&#xED;pica crea una imagen que es varias veces m&#xE1;s grande que el &#xE1;rea de dibujo de gran parte de los bosquejos creados en p5.js. Cambiar el tama&#xF1;o de estas im&#xE1;genes antes de que sean a&#xF1;adidas al directorio del bosquejo hace que los bosquejos carguen m&#xE1;s r&#xE1;pido, corran m&#xE1;s eficientemente y ahorra espacio en el disco duro.</p>

<p>Las im&#xE1;genes GIF, PNG y SVG soportan transparencia, lo que significa que los pixeles pueden ser invisibles o parcialmente visibles (recuerda la discusi&#xF3;n de color() y valores alpha en el Ejemplo 3-17). Las im&#xE1;genes GIF tienen transparencia de 1 bit, lo que significa que los pixeles son totalmente opacos o totalmente transparentes. Las im&#xE1;genes PNG soportan transparencia de 8 bits, lo que significa que cada pixel tiene una variable de opacidad. Los siguientes ejemplos usan los archivos clouds.gif y clouds.png para mostrar las diferencias entre los formatos. Las im&#xE1;genes est&#xE1;n dentro del directorio media que has descargado anteriormente. Aseg&#xFA;rate de incluirlas al directorio de tu bosquejo antes de probar cada ejemplo.</p>

## Ejemplo 7-4: transparencia con GIF

```javascript
var img;

function preload() {
  img = loadImage(&quot;clouds.gif&quot;);
}

function setup() {
  createCanvas(480, 120);
}

function draw() {
  background(204);
  image(img, 0, 0);
  image(img, 0, mouseY * -1);
}
```

## Ejemplo 7-5: transparencia con PNG

```javascript
var img;

function preload() {
  img = loadImage(&quot;clouds.png&quot;);
}

function setup() {
  createCanvas(480, 120);
}

function draw() {
  background(204);
  image(img, 0, 0);
  image(img, 0, mouseY * -1);
}
```

## Ejemplo 7-6: mostrar una imagen SVG

```javascript
var img;

function preload() {
  img = loadImage(&quot;network.svg&quot;);
}

function setup() {
  createCanvas(480, 120);
}

function draw() {
  background(204);
  image(img, 0, 0);
  image(img, mouseX, 0);
}
```

## Nota

<p>Recuerda incluir la extensi&#xF3;n apropiada del archivo (.gif, .jpg, .png o .svg) cuando cargas la imagen. Tambi&#xE9;n aseg&#xFA;rate que el nombre de la imagen est&#xE9; escrito exactamente como aparece en el archivo, incluyendo may&#xFA;sculas y min&#xFA;sculas.</p>

## Asincronicidad

<p>&#xBF;Por qu&#xE9; necesitamos cargar las im&#xE1;genes en preload()? &#xBF;Por qu&#xE9; no usamos setup()? Hasta este punto, hemos estado asumiendo que nuestros programas corren desde la parte superior a la finerior, con cada l&#xED;nea de c&#xF3;digo siendo ejecutada completamente antes de avanzar a la siguiente. Aunque esto es generalmente cierto, en el caso de algunas funciones  como cargar im&#xE1;genes, tu navegador empezar&#xE1; el proceso de cargar la imagen, pero se saltar&#xE1; a la siguiente l&#xED;nea antes de que la imagen haya terminado de cargarase. Esto recibe el nombre de asincronicidad, o de funci&#xF3;n as&#xED;ncrona. Es un poco inesperado al principio, pero esto permite que las p&#xE1;ginas carguen y corran m&#xE1;s r&#xE1;pido en la web.</p>

<p>Para ver esto con mayor claridad, considera el siguiente ejemplo. Es id&#xE9;ntico al ejemplo 7-1, excepto que usamos loadImage() dentro de setup() en vez de preload().</p>

## Ejemplo 7-7: demonstrando la Asincronicidad

```javascript
var img;

function setup() {
  createCanvas(480, 120);
  img = loadImage(&quot;lunar.jpg&quot;);
  noLoop();
}

function draw() {
  background(204);
  image(img, 0, 0);
}
```

<p>Cuando corras este programa, te dar&#xE1;s cuenta que el lienzo para pintar est&#xE1; gris y que la imagen no est&#xE1; sinedo mostrada. El bosquejo corre la funci&#xF3;n setup() primero y luego corre la funci&#xF3;n draw(). En la l&#xED;nea de loadImage(), empieza a cargar la imagen, pero contin&#xFA;a con el resto de setup() y con draw() antes de que la imagen est&#xE9; cargada. La funci&#xF3;n image() no es capaz de cargar una imagen que todav&#xED;a no est&#xE9; cargada.</p>

<p>Para ayudar con este problema, p5.js tiene la funci&#xF3;n preload(). A diferencia de setup(), la funci&#xF3;n preload() forza al programa a esperar hasta que todo est&#xE9; cargado. Es mejor hacer las llamadas para cargar archivos dentro de preload(), y hacer toda la configuraci&#xF3;n en setup().</p>

<p>Alternativamente, en vez de usar preload(), puedes usar algo llamado funci&#xF3;n de retrollamada (callback).</p>

## Ejemplo 7-8: cargando con un callback

```javascript
function setup() {
  createCanvas(480, 120);
  loadImage(&quot;lunar.jpg&quot;, drawImage);
  noLoop();
}

function draw() {
  background(200);
}

function drawImage(img) {
  image(img, 0, 0);
}
```

<p>En este ejemplo, a&#xF1;adimos un segundo argumento a loadImage(), que es la funci&#xF3;n que queremos que corra despu&#xE9;s de que la carga es completada. Una vez que la imagen ha cargado, la funci&#xF3;n callback drawImage() es autom&#xE1;ticamente llamada, con un argumento, la imagen que ha sido cargada.</p>

<p>No hay necesidad de crear una variable global para guardar la imagen. La imagen es pasada directamente a la funci&#xF3;n callback, con el nombre del par&#xE1;metro escogido en la definici&#xF3;n de la funci&#xF3;n.</p>

## Fuentes de letras

<p>p5.js puede mostrar texto en fuentes distintas que la por defecto. Puedes usar cualquier fuente que est&#xE9; en tu computador (son llamadas fuentes del sistema). Ten en cuenta que si est&#xE1;s compartiendo esto en la web, otra gente necesitar&#xE1; a&#xF1;adir la fuente de sistema para poder ver el texto en la fuente que escogiste. Hay un n&#xFA;mero de fuentes que la mayor parte de los computadores y dispositivos tienen: estas incluyen &quot;Arial&quot;, &quot;Courier&quot;, &quot;Courier New&quot;, &quot;Georgia&quot;, &quot;Helvetica&quot;, &quot;Palatino&quot;, &quot;Times New Roman&quot;, &quot;Trebuchet MS&quot; y &quot;Verdana&quot;.</p>

## Ejemplo 7-9: dibujando con fuentes

<p>Puedes usar la funci&#xF3;n textFont() para configurar la fuente actual. Puedes dibujar letras en la pantalla con la funci&#xF3;n text() y puedes cambiar el tama&#xF1;o con la funci&#xF3;n textSize():</p>

```javascript
function setup() {
  createCanvas(480, 120);
  textFont(&quot;Arial&quot;);
}

function draw() {
  background(102);
  textSize(32);
  text(&quot;one small step for man...&quot;, 25, 60);
  textSize(16);
  text(&quot;one small step for man...&quot;, 27, 90);
}
```

<p>El primer par&#xE1;metro de text() son los caracteres a ser dibujados en la pantalla. (Date cuenta que los caracteres est&#xE1;n entre comillas). Los segundo y tercer par&#xE1;metros definen la ubicaci&#xF3;n horizontal y vertical. La ubicaci&#xF3;n est&#xE1; basada en la base del texto (ver Figura 7-1).</p>

## Ejemplo 7-10: usar una fuente de la web

<p>Si no quieres estar limitado a esta peque&#xF1;a lista de fuentes, puedes usar una de la web. Dos sitios web que son buenos recursos para encontrar fuentes web con licencias abiertas para usar con p5.js son GoogleFonts y la Open Font Library.</p>

<p>Para usar una webfont en tu prorgrama, deber&#xE1;s referenciarla en tu archivo index.html. Cuando escoges una fuente desde cualquiera de estas librer&#xED;as mencionadas, te mostar&#xE1; una l&#xED;nea de c&#xF3;digo para a&#xF1;adir a tu archivo HTML. Cuando copias y pegas este c&#xF3;digo en cualquier parte dentro de la secci&#xF3;n head de tu HTML, tu archivo se ver&#xE1; algo as&#xED;:</p>

```html
<html>
<head>
  <script type="text/javascript" src="../lib/p5.js"></script>
  <script type="text/javascript" src="sketch.js"></script>
  <link href="http://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
</head>
<body>
</body>
</html>
```

<p>Una vez que hayas referenciado la fuente, puedes usarla con textFont() tal como las fuentes de sistema:</p>

```javascript
function setup() {
  createCanvas(480, 120);
  textFont(&quot;Source Code Pro&quot;);
}

function draw() {
  background(102);
  textSize(28);
  text(&quot;one small step for man...&quot;, 25, 60);
  textSize(16);
  text(&quot;one small step for man...&quot;, 27, 90);
}
```

## Ejemplo 7-11: define el trazado del texto y el relleno

<p>Tal como las figuras, el texto es afectado por las funciones stroke() y fill(). El siguiente ejemplo resulta en texto negro con borde blanco:</p>

```javascript
function setup() {
  createCanvas(480, 120);
  textFont(&quot;Source Code Pro&quot;);
  fill(0);
  stroke(255);
}

function draw() {
  background(102);
  textSize(28);
  text(&quot;one small step for man...&quot;, 25, 60);
  textSize(16);
  text(&quot;one small step for man...&quot;, 27, 90);
}
```

## Ejemplo 7-12: dibuja el texto en un recuadro

<p>Puedes tambi&#xE9;n definir que el texto se dibuje dentro de un recuadro a&#xF1;adiendo los par&#xE1;metros cuarto y quinto para especificar el ancho y altura del recuadro:</p>

```javascript
function setup() {
  createCanvas(480, 120);
  textFont(&quot;Source Code Pro&quot;);
  textSize(24);
}

function draw() {
  background(102);
  text(&quot;one small step for man...&quot;, 26, 24, 240, 100);
}
```

## Ejemplo 7-13: guardar el texto en una variable

<p>En el ejemplo anterior, las palabras dentro de la funci&#xF3;n text() hacen que el c&#xF3;digo sea dif&#xED;cil de leer. Podemos guardar estas palabras en una variable para asegurar que el c&#xF3;digo sea m&#xE1;s modular. Aqu&#xED; est&#xE1; una nueva versi&#xF3;n del ejemplo anterior que usa una variable:</p>

```javascript
var quote = &quot;one small step for man...&quot;;

function setup() {
  createCanvas(480, 120);
  textFont(&quot;Source Code Pro&quot;);
  textSize(24);
}

function draw() {
  background(102);
  text(quote, 26, 24, 240, 100);
}
```

<p>Hay un conjunto de funciones adicionales que afectan c&#xF3;mo las letras son mostradas en la pantalla. Son explicadas, con ejemplos, en la categor&#xED;a de Tipograf&#xED;a en la Referencia de p5.js.</p>

## Robot 5: media

<p>A diferencia de los robots creados con l&#xED;neas y rect&#xE1;ngulos dibujados en p5.js durante los cap&#xED;tulos anteriores, estos robots fueron creados con un programa de dibujo vectorial. Para algunas figuras, es m&#xE1;s f&#xE1;cil apuntar y hacer click con un software como Inkscape o Illustrator que definir las figuras con coordenadas en c&#xF3;digo.</p>

<p>Existe un compromiso al seleccionar una t&#xE9;cnica para creaci&#xF3;n de im&#xE1;genes por sobre otra. Cuando defines figuras en p5.js, existe mayor flexibilidad para modificarlas mientras el programa est&#xE1; corriendo. Si las figuras est&#xE1;n definidas en otro lugar y luego cargadas a p5.js, los cambios est&#xE1;n limitados a la posici&#xF3;n, &#xE1;ngulo y tama&#xF1;o. Cuando cargas cada robot desde un archivo SVG, como este ejemplo muestra, las variaciones destacadas en el Robot 2 (ver &quot;Robot 2: variables&quot;) son imposibles.

</p><p>Las im&#xE1;genes pueden ser cargadas con un programa para traer visuales creadas en otros programas o capturadas con una c&#xE1;mara. Con esta imagen en el fondo, nuestros robots ahora est&#xE1;n buscando formas de vida en Noruega en los inicios del siglo 20.</p>

<p>Los archivos SVG y PNG usados en este ejemplo pueden ser descargados desde http://p5js.org/learn/books/media.zip:</p>

```javascript
var bot1;
var bot2;
var bot3;
var landscape;

var easing = 0.05;
var offset = 0;

// Precarga las im&#xE1;genes
function preload() {
  bot1 = loadImage(&quot;robot1.svg&quot;);
  bot2 = loadImage(&quot;robot2.svg&quot;);
  bot2 = loadImage(&quot;robot3.svg&quot;);
  landscape = loadImage(&quot;alpine.svg&quot;);
}

function setup() {
  createCanvas(720, 480);
}

function draw() {
  // Definir la imagen &quot;landscape&quot; como funci&#xF3;n
  // Esta imagen debe tener el mismo ancho y altura que el programa
  background(landscape);

  // Definir el offset izquierdo y derecho y aplicar
  // el suavizado para hacer la transici&#xF3;n m&#xE1;s suave
  var targetOffset = map(mouseY, 0, height, -40, 40);
  offset += (targetOffset - offset) * easing;

  // Dibuja el robot izquierdo
  image(bot1, 85 + offset, 65);

  // Dibuja el robot derecho m&#xE1;s peque&#xF1;o y
  // haz que tenga un menor offset
  var smallerOffset = offset * 0.7;
  image(bot2, 510 + smallerOffset, 140, 78, 248);

  // Dibuja el robot m&#xE1;s peque&#xF1;o, dale un offset menor
  smallerOffset *= -0.5;
  image(bot3, 410 + smallerOffset, 225, 39, 124);
}
```

</section>

<section data-type="chapter" id="capitulo_08_movimiento">

<h1>Cap&#xED;tulo 8. Movimiento</h1>

<p>Tal como un folioscopio, la animaci&#xF3;n en la pantalla es creada para dibujar una imagen, luego otra, y as&#xED;. La ilusi&#xF3;n de movimiento fluido es creada por persistencia de visi&#xF3;n. Cuando un conjunto de im&#xE1;genes similares es presentado a una tasa suficiente, nuestros cerebros traducen estas im&#xE1;genes en movimiento.</p>

## Cuadros

<p>Para crear movimiento fluido, p5.js trata de correr el c&#xF3;digo dentro de draw() a una tasa de 60 cuadros por segundo. Un cuadro es una ejecuci&#xF3;n de la funci&#xF3;n draw() y la tasa de cuadros equivale a cu&#xE1;ntos cuadros son dibujados cada segundo. Entonces, un programa que dibuja 60 cuadros cpor segundo corre todo el c&#xF3;digo dentro de la funci&#xF3;n draw() 60 veces por segundo.</p>

## Ejemplo 8-1: ve la tasa de cuadros

<p>Para confirmar la tasa de cuadros, podemos usar la consola del navegador que aprendimos a usar en el Cap&#xED;tulo 1. La funci&#xF3;n frameRate() te arroja la velocidad actual de tu programa. Abre la consola, corre este programa y revisa los valores impresos:</p>

```javascript

function draw() {
  var fr = frameRate();
  print(fr);
}
```

## Ejemplo 8-2: define la tasa de cuadros

<p>La funci&#xF3;n frameRate() puede tambi&#xE9;n cambiar la velocidad a la que el programa corre. Cuando es ejecutada sin par&#xE1;metro (como en el Ejemplo 8-1), arroja la actual tasa de cuadros. Sin embargo, cuando la funci&#xF3;n frameRate() es llamada con un par&#xE1;metro, define la tasa de cuadros a ese valor. Para ver el resultado, ejecuta las distintas versiones de frameRate() de este ejemplo, descoment&#xE1;ndolas:</p>

```javascript
function setup() {
  frameRate(30);    // Treinta cuadros por segundo
  //frameRate(12);  // Doce cuadros por segundo
  //frameRate(2);   // Dos cuadros por segundo
  //frameRate(0.5); // Un cuadro cada dos segundos
}
function draw() {
  var fr = frameRate();
  print(fr);
}
```

## Nota:

<p>p5.js trata de correr el c&#xF3;digo a una tasa de 60 cuadros por segundo, pero si tarda m&#xE1;s de de 1/60 segundos en correr el m&#xE9;todo draw(), entonces la tasa decrecer&#xE1;. La funci&#xF3;n frameRate() especifica solo la tasa m&#xE1;xima, y la tasa real para cualquier programa depende en el computador corriendo el c&#xF3;digo.</p>

## Velocidad y direcci&#xF3;n

<p>Para crear exemplos de movimiento fluido, creamos variables que guardan n&#xFA;meros y los modifican un poco cada cuadro.</p>

## Ejemplo 8-3: mueve una figura.

<p>El siguiente ejemplo mueve una figura de izquierda a derecha, actualizando la variable x:</p>

```javascript
var radius = 40;
var x = -radius;
var speed = 0.5;

function setup() {
  createCanvas(240, 120);
  ellipseMode(RADIUS);
}

function draw() {
  background(0);
  x += speed;   // Aumenta el valor de x
  arc(x, 60, radius, radius, 0.52, 5.76);
}
```

<p>Cuando corres este c&#xF3;digo, observar&#xE1;s que la figura se mueve m&#xE1;s all&#xE1; del borde derecho de la pantalla cuando el valor de la variable x es mayor que el ancho de la ventana. El valor de x sigue aumentando, pero la figura ya no es visible.</p>

## Ejemplo 8-4: dar la vuelta

<p>Existen muchas alternativas a este comportamiento, que puedes escoger de acuerdo a tu preferencia. Primero, extenderemos el c&#xF3;digo para mostrar c&#xF3;mo mover la figura de vuelta al borde izquierdo de la pantalla despu&#xE9;s de que desaparece del borde derecho. En este caso, imagina la pantalla como un cilindro aplanado, con la figura movi&#xE9;ndose por fuera para volver al borde izquierdo:</p>

```javascript
var radius = 40;
var x = -radius;
var speed = 0.5;

function setup() {
  createCanvas(240, 120);
  ellipseMode(RADIUS);
}

function draw() {
  background(0);
  x += speed;     // Aumenta el valor de x
  if (x &gt; width + radius) { // Si la figura est&#xE1; fuera de la pantalla
    x = - radius; // Mueve la figura al borde izquierdo
  }
  arc(x, 60, radius, radius, 0.52, 5.76);
}
```

<p>En cada viaje alrededor de draw(), el c&#xF3;digo prueba si el valor de x ha aumentado m&#xE1;s all&#xE1; del ancho de la pantalla (sumado al radio de la figura). Si lo ha hecho, hacemos que el valor de x sea negativo nuevamente, para que cuando siga aumentando, entre a la pantalla por la izquierda. Mira la Figura 8-1 para ver un diagrama de c&#xF3;mo funciona.</p>

## Ejemplo 8-5: rebota contra la pared

<p>En este ejemplo, extenderemos el Ejemplo 8-3 para que la figura cambie de direcci&#xF3;n cuando llegue a un borde, en vez de volver a aparecer por la izquierda. Para hacer que esto pase, a&#xF1;adimos una nueva variable para almacenar la direcci&#xF3;n de la figura. Un valor de direcci&#xF3;n de 1 mueve la figura hacia la derecha, mientras que un valor de -1 la mueve hacia la izquierda:</p>

```javascript
var radius = 40;
var x = 110;
var speed = 0.5;
var direction = 1;

function setup() {
  createCanvas(240, 120);
  ellipseMode(RADIUS);
}

function draw() {
  background(0);
  x += speed * direction;
  if ((x &gt; width-radius) || (x &lt; radius)) {
    direction = -direction;   // Cambiar direcci&#xF3;n
  }
  if (direction == 1) {
    arc(x, 60, radius, radius, 0.52, 5.76); // Hacia la derecha
  } else {
    arc(x, 60, radius, radius, 3.67, 8.9);  // Hacia la izquierda
  }
}
```

<p>Cuando la figura llega a un borde, este c&#xF3;digo invierte la direcci&#xF3;n de la figura, cambiando el signo de la variable direcci&#xF3;n. Por ejemplo, si la variable direcci&#xF3;n es positiva cuando la figura llega a un borde, el c&#xF3;digo la invierte a negativa.</p>

## Posiciones intermedias (tweening)

<p>A veces quieres animar una figura para ir de un punto de la pantalla a otro. Con unas pocas l&#xED;neas de c&#xF3;digo, puedes configurar la posici&#xF3;n inicial y final, y luego calcular las posiciones entremedio (tween) en cada cuadro.</p>

## Ejemplo 8-6: calcula las posiciones intermedias

<p>Para hacer que el ejemplo de este c&#xF3;digo sea modular, hemos creado un grupo de variables en la parte superior. Corre el c&#xF3;digo unas cuantas veces y cambia los valores para ver c&#xF3;mo este c&#xF3;digo puede mover a la figura desde cualquier ubicaci&#xF3;n a cualquier otra en cualquier rango de velocidades. Cambia la variable step para alterar la velocidad:</p>

```javascript
var startX = 20;  // Coordenada x inicial
var stopX = 160;  // Coordenada x final
var startY = 30;  // Coordenada y inicial
var stopY = 80;   // Coordenada y final
var x = startX;   // Coordenada x actual
var y = startY;   // Coordenada y actual
var step = 0.005; // createCanvas para cada paso (0.0 a 1.0)
var pct = 0.0;    // Porcentaje avanzado (0.0 a 1.0)

function setup() {
  createCanvas(240, 120);
}

function draw() {
  background(0);
  if (pct &lt; 1.0) {
    x = startX + ((stopX - startX) * pct);
    y = startY + ((stopY - startY) * pct);
    pct += step;
  }
  ellipse(x, y, 20, 20);
}
```

## Aleatorio

<p></p>A diferencia del movimiento linear y suave t&#xED;pico en las gr&#xE1;ficas por computadora, el movimiento en el mundo f&#xED;sico es usualmente idiosincr&#xE1;tico. Por ejemplo, si pensamos en una hoja flotando hacia la tierra, o una hormiga caminando por un terreno rugoso. Podemos simular las cualidades impredecibles del mundo generando n&#xFA;meros aleatorios. La funci&#xF3;n random() calcula estos valores, podemos definir un rango para afinar la cantidad de desorden en un programa.<p></p>

## Ejemplo 8-7: genera valores aleatorios

<p>El siguiente ejemplo corto imprime valores aleatorios en la consola, con el rango limitado por la posici&#xF3;n del rat&#xF3;n:</p>

```javascript
function draw() {
  var r = random(0, mouseX);
  print(r);
}
```

## Ejemplo 8-8: dibuja aleatoriamente

<p>Construyendo sobre el Ejemplo 8-7, este ejemplo usa valores de la funci&#xF3;n random() para cambiar la posici&#xF3;n de l&#xED;neas en el lienzo. Cuando el rat&#xF3;n est&#xE1; a la izquierda del lienzo, el cambio es peque&#xF1;o; si se mueve a la derecha, los valores de random() aumentan y el movimiento se torna m&#xE1;s exagerado. Como la funci&#xF3;n random() est&#xE1; dentro de un for loop, un nuevo valor aleatorio es calculado para cada punto de cada l&#xED;nea:</p>

```javascript
function setup() {
  createCanvas(240, 120);
}

function draw() {
  background(204);
  for (var x = 20; x &lt; width; x += 20) {
    var mx = mouseX / 10;
    var offsetA = random(-mx, mx);
    var offsetB = random(-mx, mx);
    line(x + offsetA, 20, x - offsetB, 100);
  }
}
```

## Ejemplo 8-9: mueve figuras aleatoriamente

<p>Cuando se usa para  mover figuras alrededor de la pantalla, los valores aleatorios pueden generar im&#xE1;genes que son m&#xE1;s naturales en apariencia. En el siguiente ejemplo, la posici&#xF3;n del c&#xED;rculo es modificada por valores aleatorios en cada ejecuci&#xF3;n de draw(). Como la funci&#xF3;n background() no es usad, las posiciones anteriores permanecen dibujadas:</p>

```javascript
var speed = 2.5;
var diameter = 20;
var x;
var y;

function setup() {
  createCanvas(240, 120);
  x = width/2;
  y = height/2;
  background(204);
}

function draw() {
  x += random(-speed, speed);
  y += random(-speed, speed);
  ellipse(x, y, diameter, diameter);
}
```

<p>Si observas este ejemplo el tiempo suficiente, el c&#xED;rculo podr&#xED;a dejar la pantalla y volver. Esto depende del azar, pero podr&#xED;amos a&#xF1;adir unas estructuras if o usar la funci&#xF3;n constrain() para hacer que el c&#xED;rculo no deje la pantalla.</p>

<p>La funci&#xF3;n constrain() limita el valor a un rango espec&#xED;fico, el que puede ser usado para mantener x e y dentro de los l&#xED;mites del lienzo. Al reemplazar la funci&#xF3;n draw con el siguiente c&#xF3;digo, te asegurar&#xE1;s que la elipse permanezca en la pantalla:</p>

```javascript
function draw() {
  x += random(-speed, speed);
  y += random(-speed, speed);
  x = constrain(x, 0, width);
  y = constrain(y, 0, height);
  ellipse(x, y, diameter, diameter);
}
```
## Nota

<p>La funci&#xF3;n randomSeed() puede ser usada para forzar a randon() para producir la misma secuencia de n&#xFA;meros cada vez que un programa es ejecutado. Esto es descrito con mayor detalle en la Referencia de p5.js.</p>

## Temporizadores

<p>Cada programa de p5.js cuenta el monto de tiempo que ha pasado desde que empez&#xF3;. Cuenta en milisegundos (mil&#xE9;simas de segundo), as&#xED; que despu&#xE9;s de 1 segundo el contador est&#xE1; en 1.000, despu&#xE9;s de 5 segundos est&#xE1; en 5.000 y despu&#xE9;s de un minuto en 60.000. Podemos usar este contador para gatillar animaciones en momentos espec&#xED;ficos. La funci&#xF3;n millis() arroja el valor del contador.</p>

## Ejemplo 8-10: el tiempo pasa

<p>Puedes ver c&#xF3;mo el tiempo pasa cuando corres este programa:</p>

 ```javascript
 function draw() {
   var timer = millis();
   print(timer);
 }
 ```

## Ejemplo 8-11: gatillando eventos temporizados

<p>Cuando se combina con un bloque if, los valores de millis() pueden ser usados para secuenciar tanto animaciones como eventos del programa. Por ejemplo, despu&#xE9;s de que han pasado dos segundos, el c&#xF3;digo dentro del bloque if puede gatillar un cambio. En este ejemplo, las variables llamadas time1 y time2 deerminan cu&#xE1;ndo cambiar el valor de la variable x:</p>

 ```javascript
var time1 = 2000;
var time2 = 4000;
var x = 0;

function setup() {
  createCanvas(480, 120);
}

function draw() {
  var currentTime = millis();
  background(204);
  if (currentTime &gt; time2) {
    x -= 0.5;
  } else if (currentTime &gt; time1) {
    x += 2;
  }
  ellipse(x, 60, 90, 90);
}
```

## Circular

<p>Si eres un as de la trigonometr&#xED;a, ya sabes cu&#xE1;n incre&#xED;bles son las funciones seno y coseno. Si no lo eres, esperamos que los siguientes ejemplos pueden gatillar tu inter&#xE9;s. no discutiremos la matem&#xE1;tica en detalle aqu&#xED;, pero aqu&#xED; mostraremos unas pocas aplicaciones para generar movimiento fluido.</p>

<p>La figura 8-2 muestra una visualizaci&#xF3;n de valores de la funci&#xF3;n seno y c&#xF3;mo se relacionan con &#xE1;ngulos. En la parte superior e inferior de la onda, observa c&#xF3;mo la tasa de cambio (el cambio en el eje vertical) desacelera, para y luego cambia de direcci&#xF3;n. Es esta cualidad de la curva lo que genera un movimiento interesante.</p>

<p>Las funciones sin() y cos() en p5.js arrojan valores entre -1 y 1 para la funci&#xF3;n seno y coseno del &#xE1;ngulo especificado. Tal como arc(), los &#xE1;ngulos deben ser escritos en radianes (ver Ejemplo 3-7 y Ejemplo 3-8 para un recordatorio de c&#xF3;mo funcionan los radianes). Para ser &#xFA;til para dibujar, los valores float arrojados por sin() y cos() son usualmente multiplicados por un valor m&#xE1;s grande.</p>

## Ejemplo 8-12: valores de la onda sinusoidal

<p>Este ejemplo muestra c&#xF3;mo los valores de sin() oscilan entre -1 y 1 a medida que el &#xE1;ngulo aumenta. Con la funci&#xF3;n map(), la variable sinval es convertida desde este rango a valores de 0 a 255. Este nuevo valor es usado para definir el color del fondo del lienzo:</p>

```javascript
var angle = 0.0;

function draw() {
  var sinval = sin(angle);
  print(sinval);
  var gray = map(sinval, -1, 1, 0, 255);
  background(gray);
  angle += 0.1;
}
```

## Ejemplo 8-13: movimiento de una onda sinusoidal

<p>Este ejemplo muestra c&#xF3;mo estos valores son convertidos a movimiento:</p>

```javascript
var angle = 0.0;
var offset = 60;
var scalar = 40;
var speed = 0.05;

function setup() {
  createCanvas(240, 120);
}

function draw() {
  background(0);
  var y1 = offset + sin(angle) * scalar;
  var y2 = offset + sin(angle + 0.4) * scalar;
  var y3 = offset + sin(angle + 0.8) * scalar;
  ellipse( 80, y1, 40, 40);
  ellipse(120, y2, 40, 40);
  ellipse(160, y3, 40, 40);
  angle += speed;
}
```

## Ejemplo 8-14: movimiento circular

<p>Cuando las funcioens sin() y cos() son usadas en conjunto, pueden producir movimiento circular. Los valores de la funci&#xF3;n cos() proveen los valores de la coordenada x, y los valores de la funci&#xF3;n sin() proveen la coordenada y. Ambos son multiplicados por una variable llamada scalar para cambiar el radio del movimiento y son sumados con un valor offset para situar el centro de un movimiento circular:</p>

```javascript
var angle = 0.0;
var offset = 60;
var scalar = 30;
var speed = 0.05;

function setup() {
  createCanvas(120, 120);
  background(204);
}

function draw() {
  var x = offset + cos(angle) * scalar;
  var y = offset + sin(angle) * scalar;
  ellipse(x, y, 40, 40);
  angle += speed;
}
```

## Ejemplo 8-15: espirales

<p>Un peque&#xF1;o cambio hecho para aumentar el valor scalar en cada cuadro produce una espiral en vez de un c&#xED;rculo:</p>

```javascript
var angle = 0.0;
var offset = 60;
var scalar = 2;
var speed = 0.05;

function setup() {
  createCanvas(120, 120);
  fill(0);
  background(204);
}

function draw() {
  var x = offset + cos(angle) * scalar;
  var y = offset + sin(angle) * scalar;
  ellipse(x, y, 2, 2);
  angle += speed;
  scalar += speed;
}
```

Robot 6: movimiento

<p>En este ejemplo, las t&#xE9;cnicas para movimiento aleatorio y circular son aplicadas al robot. La funci&#xF3;n background() fue removida para ver m&#xE1;s claramente c&#xF3;mo la posici&#xF3;n del robot y su cuerpo cambian.</p>

<p>En cada cuadro, un n&#xFA;mero aleatorio entre -4 y 4 es a&#xF1;adido a la coordenada x, y un n&#xFA;mero aleatorio entre -1 y 1 es a&#xF1;adido a la coordenada y. Esto causa que el robot se mueva m&#xE1;s de izquierda a derecha que de arriba a abajo. Los n&#xFA;meros calculados por la funci&#xF3;n sin() cambian la altura del cuello para que oscile entre 50 y 100 pixeles de altura:</p>

```javascript
var x = 180;          // Coordenada x
var y = 400;          // Coordenada y
var bodyHeight = 153; // Altura del cuerpo
var neckHeight = 56;  // Altura del cuello
var radius = 45;      // Radio de la cabeza
var angle = 0.0;      // &#xC1;ngulo de movimiento

function setup() {
  createCanvas(360, 480);
  ellipseMode(RADIUS);
  background(204);
}

function draw() {
  // Cambia la posici&#xF3;n en un monto aleatorio peque&#xF1;o
  x += random(-4, 4);
  y += random(-1, 1);

  // Cambia la altura del cuello
  neckHeight = 80 + sing(angle) * 30;
  angle += 0.05;

  // Ajusta la altura de la cabeza
  var ny = y - bodyHeight - neckHeight - radius;

  // Cuello
  stroke(102);
  line(x +  2, y - bodyHeight, x +  2, ny);
  line(x + 12, y - bodyHeight, x + 12, ny);
  line(x + 22, y - bodyHeight, x + 22, ny);

  // Antenas
  line(x + 12, ny, x - 18, ny - 43);
  line(x + 12, ny, x + 42, ny - 99);
  line(x + 12, ny, x + 78, ny + 15);

  // Cuerpo
  noStroke();
  fill(102);
  ellipse(x, y - 33, 33, 33);
  fill(0);
  rect(x - 45, y - bodyHeight, 90, bodyHeight - 33);
  fill(102);
  rect(x - 45, y - bodyHeight + 17, 90, 6);

  // Cabeza
  fill(0);
  ellipse(x + 12, ny, radius, radius);
  fill(255);
  ellipse(x + 24, ny - 6, 14, 14);
  fill(0);
  ellipse(x + 24, ny - 6, 3, 3);
}
```
</section>

<section data-type="chapter" id="capitulo_09_funciones">

<h1>Cap&#xED;tulo 9. Funciones</h1>

<p>Las funciones son los bloques fundamentales de los programas hechos en p5.js. Han aparecido en cada ejemplo que hemos presentado. Por ejemplo, hemos frecuentemente usado la funci&#xF3;n createCanvas(), la funci&#xF3;n line(), y la funci&#xF3;n fill(). Este cap&#xED;tulo muestra c&#xF3;mo escribir nuevas funciones para extender las capacidades de p5.js m&#xE1;s all&#xE1; de sus caracter&#xED;sticas incorporadas.</p>

<p>El poder de las funciones es su modularidad. Las funciones son unidades de software independientes que son usadas para construir programas complejos - como bloques de LEGO, donde cada tipo de ladrillo sirve para un prop&#xF3;sito espec&#xED;fico y para lograr un modelo complejo requiere usar las diferentes partes en conjunto. Como con las funciones, el verdadero poder de estos ladrillos es la habilidad de construir muchas formas distintas usando el mismo conjunto de elementos. El mismo grupo de LEGOs que forma una navae espacial puede ser reusado para construir un cami&#xF3;n, un rascacielos y muchos otros objetos.</p>

<p>Las funciones son &#xFA;tiles si quieres dibujar una forma m&#xE1;s compleja como un &#xE1;rbol, una y otra vez. La funci&#xF3;n para dibujar un &#xE1;rbol puede estar compuesta con las funciones incorporadas de p5.js, como line(), para crear la forma. Despu&#xE9;s de que el c&#xF3;digo para dibujar el &#xE1;rbol es escrito, no necesitas pensar sobre los detalles de dibujar un &#xE1;rbol nuevamente - puedes simplemente escribir tree() (o alg&#xFA;n otro nombre que le hayas puesto a la funci&#xF3;n) para dibujar la figura. Las funciones permiten que una secuencia compleja de declaraciones pueda ser abstra&#xED;da, para que te puedas enfocar en una meta de alto nivel (como dibujar un &#xE1;rbol), y no los detalles de la implementaci&#xF3;n (las funciones line() que definen la forma del &#xE1;rbol). Una vez que una funci&#xF3;n es definida, el c&#xF3;digo dentro de la funci&#xF3;n no necesita ser repetido.</p>

## Funciones b&#xE1;sicas

<p>Un computador corre los programas una l&#xED;nea de c&#xF3;digo a la vez. Cuando una funci&#xF3;n es ejecutada, el computador salta a donde la funci&#xF3;n est&#xE1; definida y corre el c&#xF3;digo ah&#xED;, luego vuelve a donde estaba anteriormente.</p>

## Ejemplo 9-1: tira los dados

<p>Este comportamiento es ilustrado con la funci&#xF3;n rollDice() escrita para este ejemplo. Cuando el programa empieza, corre el c&#xF3;digo en setup() y luego para. El programa toma un desv&#xED;o y corre el c&#xF3;digo dentro de rollDice() cada vez que aparece.</p>

```javascript
function setup() {
  print(&quot;&#xA1;Listo para lanzar los dados!&quot;);
  rollDice(20);
  rollDice(20);
  rollDice(6);
  print(&quot;Listo.&quot;);
}

function rollDice(numSides) {
  var d = 1 + int(random(numSides));
  print(&quot;Lanzando... &quot; + d);
}
```

<p>Las dos l&#xED;neas de c&#xF3;digo en rollDice() seleccionan un n&#xFA;mero aleatorio entre 1 y el n&#xFA;mero de caras del dado, e imprime ese n&#xFA;mero a la consola. Como los n&#xFA;meros son aleatorios, ver&#xE1;s diferentes n&#xFA;meros cada vez que el prorgama es ejecutado:</p>

<p>Cada vez que la funci&#xF3;n rollDice() es ejecutada dentro de setup(), el c&#xF3;digo dentro de la funci&#xF3;n corre de arriba a abajo, luego el programa contin&#xFA;a con la siguiente l&#xED;nea dentro de setup().</p>

<p>La funci&#xF3;n random() (descrita en &quot;Aleatorio&quot;) arroja un n&#xFA;mero entre 0 y hasta (pero sin incluir) el n&#xFA;mero especificado. Entonces random(6) entrega un n&#xFA;mero entre 0 y 5.99999... Como random() arroja un n&#xFA;mero con punto decimal, tambi&#xE9;n usamos la funci&#xF3;n int() para convertir el n&#xFA;mero a uno entero.  Entonces int(random(6)) arrojar&#xE1; 0, 1, 2, 3, 4 o 5. Como muchas otros casos en este libro, contar desde 0 hace m&#xE1;s f&#xE1;cil usar los resultados de random() con otros c&#xE1;lculos.</p>

## Ejemplo 9-2: otra manera de tirar los dados

<p>Si un programa equivalente hubiera sido hecho sin la funci&#xF3;n rollDice(), hubiera sido as&#xED;:</p>

```javascript
function setup() {
  print(&quot;&#xA1;Listo para lanzar los dados!&quot;);
  var d1 = 1 + int(random(20));
  print(&quot;Lanzando... &quot; + d1);
  var d2 = 1 + int(random(20));
  print(&quot;Lanzando... &quot; + d2);
  var d3 = 1 + int(random(6));
  print(&quot;Lanzando... &quot; + d3);
  print(&quot;Listo.&quot;);
}
```

<p>La funci&#xF3;n rolldice() en el Ejemplo 9-1 hace que el c&#xF3;digo sea m&#xE1;s f&#xE1;cil de leer y mantener. El programa es m&#xE1;s claro, porque el nombre de la funci&#xF3;n claramente determina su prop&#xF3;sito. En este ejemplo, podemos ver la funci&#xF3;n random() en setup(), pero su uso no es tan obvio. El n&#xFA;mero de lados en un dado es m&#xE1;s claro con una funci&#xF3;n: cuando el c&#xF3;digo dice rollDice(6), es obvio que est&#xE1; simulando el lanzamiento de un dado de seis caras. Adem&#xE1;s, el Ejemplo 9-1 es f&#xE1;cil de mantener, porque la informaci&#xF3;n no est&#xE1; repetida. La frase Lanzando... se repite tres veces en este caso. Si quieres cambiar el texto a algo distinto, tienes que actualizar el c&#xF3;digo en tres lugares, en vez de hacer una sola edici&#xF3;n dentro de la funci&#xF3;n rollDice(). Adem&#xE1;s, como ver&#xE1;s en el Ejemplo 9-5, una funci&#xF3;n puede hacer un programa mucho m&#xE1;s corto (y por lo tanto m&#xE1;s f&#xE1;cil de mantener y leer), lo que ayuda a reducir el potencial n&#xFA;mero de errores.</p>

## Hacer una funci&#xF3;n

<p>En esta secci&#xF3;n, dibujaremos una lechuza para explicar los pasos involucrados en hacer una funci&#xF3;n.</p>

## Ejemplo 9-3: dibuja la lechuza

<p>Primero, dibujaremos la lechuza sin usar una funci&#xF3;n:</p>

```javascript
function setup() {
  createCanvas(480, 120);
}

function draw() {
  background(204);
  translate(110, 110);
  stroke(0);
  strokeWeight(70);
  line(0, -35, 0, -65); // Cuerpo
  noStroke();
  fill(255);
  ellipse(-17.5, -65, 35, 35);  // Pupila izquierda
  ellipse( 17.5, -65, 35, 35);  // Pupila derecha
  arc(0, -65, 70, 70, 0, PI);   // Barbilla
  fill(0);
  ellipse(-14, -65, 8, 8);  // Ojo izquierdo
  ellipse( 14, -65, 8, 8);  // Ojo derecho
  quad(0, -58, 4, -51, 0, -44, -4, -51);  // Pico
}
```

<p>Observa que la funci&#xF3;n translate() es usada para mover el origen (0, 0) 110 pixeles a la derecha y 110 pixeles hacia abajo. Luego la leechuza es dibujada relativamente al (0,0), con sus coordenadas algunas veces positivas y otras negativas, centradas alrededor del nuevo punto (0,0). (Ver Figura 9-1).</p>

## Ejemplo 9-4: Dos son compa&#xF1;&#xED;a

<p>El c&#xF3;digo del Ejemplo 9-3 es razonable si solo hay una lechuza, pero cuando a&#xF1;adimos una segunda, el largo del c&#xF3;digo es casi el doble:</p>

```javascript
function setup() {
  createCanvas(480, 120);
}

function draw() {
  background(204);

  // Lechuza izquierda
  translate(110, 110);
  stroke(0);
  strokeWeight(70);
  line(0, -35, 0, -65); // Cuerpo
  noStroke();
  fill(204);
  ellipse(-17.5, -65, 35, 35);  // Pupila izquierda
  ellipse( 17.5, -65, 35, 35);  // Pupila derecha
  arc(0, -65, 70, 70, 0, PI);   // Barbilla
  fill(0);
  ellipse(-14, -65, 8, 8);  // Ojo izquierdo
  ellipse( 14, -65, 8, 8);  // Ojo derecho
  quad(0, -58, 4, -51, 0, -44, -4, -51);  // Pico

  // Lechuza derecha
  translate(70, 0);
  stroke(0);
  strokeWeight(70);
  line(0, -35, 0, -65); // Cuerpo
  noStroke();
  fill(255);
  ellipse(-17.5, -65, 35, 35);  // Pupila izquierda
  ellipse( 17.5, -65, 35, 35);  // Pupila derecha
  arc(0, -65, 70, 70, 0, PI);   // Barbilla
  fill(0);
  ellipse(-14, -65, 8, 8);  // Ojo izquierdo
  ellipse( 14, -65, 8, 8);  // Ojo derecho
  quad(0, -58, 4, -51, 0, -44, -4, -51);  // Pico
}
```

<p>El programa crece de 21 l&#xED;neas de c&#xF3;digo a 34, el c&#xF3;digo para dibujar la primera lechuza fue copiado y pegado en el programa y una funci&#xF3;n translate fue insertada para moverla 70 pixeles a la derecha. Esto es una manera tediosa e ineficiente de dibujar la segunda lechuza, no sin mencionar el dolor de cabeza que ser&#xE1; a&#xF1;adir una tercera lechuza con este m&#xE9;todo. Pero duplicar el c&#xF3;digo es innecesario, porque este es el tipo de situaci&#xF3;n donde una funci&#xF3;n puede llegar al rescate.</p>

## Ejemplo 9-5: una funci&#xF3;n lechuza

<p>En este ejemplo, una funci&#xF3;n es introducida para dibujar dos lechuzas con el mismo c&#xF3;digo. Si hacemos que el c&#xF3;digo que dibuja una lechuza en la pantalla sea una nueva funci&#xF3;n, entonces el c&#xF3;digo solo necesita aparecer una vez en el programa:</p>

```javascript
function setup() {
  createCanvas(480, 120);
}

function draw() {
  background(204);
  owl(110, 110);
  owl(180, 110);
}

function owl(x,y) {
  push();
  translate(x,y);
  stroke(0);
  strokeWeight(70);
  line(0, -35, 0, -65); // Cuerpo
  noStroke();
  fill(255);
  ellipse(-17.5, -65, 35, 35);  // Pupila izquierda
  ellipse( 17.5, -65, 35, 35);  // Pupila derecha
  arc(0, -65, 70, 70, 0, PI);   // Barbilla
  fill(0);
  ellipse(-14, -65, 8, 8);  // Ojo izquierdo
  ellipse( 14, -65, 8, 8);  // Ojo derecho
  quad(0, -58, 4, -51, 0, -44, -4, -51);  // Pico
  pop();
}
```

<p>Puedes ver por las ilustraciones de este ejemplo y del Ejemplo 9-4 que tienen el mismo resultado, pero que este es m&#xE1;s corto, porque el c&#xF3;digo para usar la lechuza aparece solo una vez, dentro de la funci&#xF3;n llamada owl(). Este c&#xF3;digo es ejecutado dos veces, porque es llamado dos veces dentro de la funci&#xF3;n draw(). La lechuza es dibujada en dos ubicaciones distintas porque los par&#xE1;metros pasados a la funci&#xF3;n determinan las coordenadas x e y.</p>

<p>Los par&#xE1;metros son una parte importante de las funciones, porque proveen flexibilidad. Vimos otro ejemplo de esto en la funci&#xF3;n rollDice(), el par&#xE1;metro &#xFA;nico numSides hizo posible simular un dado de 6 caras, uno de 20 y cualquier otro n&#xFA;mero de caras.  Esto es como otras funciones de p5.js. Por ejemplo, los par&#xE1;metros de la funci&#xF3;n line() hacen posible dibujar una l&#xED;nea de un pixel a otro en el lienzo. Sin los par&#xE1;metros, la funci&#xF3;n solo ser&#xED;a capaz de dibujar una l&#xED;nea desde un punto fijo a otro fijo.</p>

<p>Cada par&#xE1;metro es una variable que es creada cada vez que la funci&#xF3;n corre. Cuando este ejemplo corre, la primera vez que la funci&#xF3;n owl es llamada, el valor del par&#xE1;metro x es 110 y el par&#xE1;metro y es 110 tambi&#xE9;n. En el segundo uso de la funci&#xF3;n, el valor de x es 180 y y es nuevamente 110. Cada valor es pasado a la funci&#xF3;n y luego cada vez que el nombre de la variable aparece dentro de la funci&#xF3;n, es reemplazado con el valor.</p>

## Ejemplo 9-6: aumentando la poblaci&#xF3;n

<p>Ahora que tenemos una funci&#xF3;n b&#xE1;sica para dibujar la lechuza en cualquier ubicaci&#xF3;n, podemos ahora dibujar muchas lechuzas eficientemente poniendo la funci&#xF3;n dentro de un for loop y cambiando el primer par&#xE1;metro cada vez que corre el loop:</p>

```javascript
function setup() {
  createCanvas(480, 120);
}

function draw() {
  background(204);
  for (var x = 35; x &lt; width + 70; x += 70) {
    owl(x, 110);
  }
}

// Insertar la funci&#xF3;n owl() del Ejemplo 9-5
```

<p>Es posible seguir a&#xF1;adiendo m&#xE1;s y m&#xE1;s par&#xE1;metros a la funci&#xF3;n para cambiar diferentes aspectos de c&#xF3;mo la lechuza es dibujada. Los valores son pasados a la funci&#xF3;n para cambiar el color de la lechuza, la rotaci&#xF3;n, la escala o el di&#xE1;metro de los ojos.</p>

## Ejemplo 9-7: lechuzas de diferentes tama&#xF1;os

<p>En este ejemplo, hemos a&#xF1;adido dos par&#xE1;metros para cambiar el valor de gris y el tama&#xF1;o de cada lechuza:</p>

```javascript
function setup() {
  createCanvas(480, 120);
}

function draw() {
  background(204);
  randomSeed(0);
  for (var i = 35; i &lt; width + 40; i += 40) {
    var gray = int(random(0, 102));
    var scalar = random(0.25, 1.0);
    owl(i, 110, gray, scalar);
  }
}

function owl(x, y, g, s) {
  push();
  translate(x,y);
  scale(s);   // Define la escala
  stroke(g);  // Define el valor de gris
  strokeWeight(70);
  line(0, -35, 0, -65); // Cuerpo
  noStroke();
  fill(255-g);
  ellipse(-17.5, -65, 35, 35);  // Pupila izquierda
  ellipse( 17.5, -65, 35, 35);  // Pupila derecha
  arc(0, -65, 70, 70, 0, PI);   // Barbilla
  fill(g);
  ellipse(-14, -65, 8, 8);  // Ojo izquierdo
  ellipse( 14, -65, 8, 8);  // Ojo derecho
  quad(0, -58, 4, -51, 0, -44, -4, -51);  // Pico
  pop();
}
```

## Valores de retorno

<p>Las funciones pueden hacer un c&#xE1;lculo y luego retornar un valor al programa principal. Hemos ya usado funciones de este tipo, incluyendo random() y sin(). Observa que cuando esta funci&#xF3;n aparece, el valor de retorno es usualmente asignado a una variable:</p>

```javascript
var r = random(1, 10);
```

<p>En este caso, la funci&#xF3;n random() retorna un valor entre 1 y 10, el que luego es asignado a la variable r.</p>

<p>Las funciones que retornan un valor son frecuentemente usadas como un par&#xE1;metro a otra funci&#xF3;n, como por ejemplo:</p>

```javascript
point(random(width), random(height));
```

<p>En este caso, los valores de random() no son asignados a una variable - son pasados como par&#xE1;metros a la funci&#xF3;n point() y usados para posicionar el punto dentro del lienzo.</p>

## Ejemplo 9-8: retorna un valor

<p>Para hacer que una funci&#xF3;n retorne un valor, especifica el dato a ser pasado de vuelta con la palabra clave return. En este ejemplo se incluye una funci&#xF3;n llamada calculateMars() que calcula el peso de una persona u objeto en nuestro planeta vecino:</p>

```javascript
function setup() {
  var yourWeight = 132;
  var marsWeight = calculateMars(yourWeight);
  print(marsWeight);
}

function calculateMars(w) {
  var newWeight = w * 0.38;
  return newWeight;
}
```

<p>Revisa la &#xFA;ltima l&#xED;nea del c&#xF3;digo del bloque, que retorna la variable newWeight. En la segunda l&#xED;nea de setup(), el valor es asignado a la variable marsWeight. (Para ver tu propio peso en Marte, cambia el valor de la variable yourWeight a tu peso).</p>

## Robot 7: funciones

<p>En contraste con el Robot 2 (ver &quot;Robot 2: variables&quot;), este ejemplo usa una funci&#xF3;n para dibujar cuatro variaciones del robot dentro del mismo programa. Como la funci&#xF3;n drawRobot() aparece cuatro veces dentro de la funci&#xF3;n draw(), el c&#xF3;digo dentro del bloque drawRobot() es ejecutado cuatro veces, cada vez con un diferente conjunto de par&#xE1;metros para cambiar la posici&#xF3;n y la altura del cuerpo del robot.</p>

<p>Observa c&#xF3;mo las variables globales en Robot 2 ahora han sido aisladas dentro de la funci&#xF3;n drawrobot(). Como estas variables aplican solamente a dibujar el robot, ellas tienen que estar dentro de las llaves que definen el bloque de la funci&#xF3;n drawRobot(). Como el valor de la variable radius no cambia, no necesita ser un par&#xE1;metro. En cambio, es definida al principio de drawRobot():</p>

```javascript
function setup() {
  createCanvas(720, 480);
  strokeWeight(2);
  ellipseMode(RADIUS);
}

function draw() {
  background(204);
  drawRobot(120, 420, 110, 140);
  drawRobot(270, 460, 260,  95);
  drawRobot(420, 310,  80,  10);
  drawRobot(570, 390, 180,  40);
}

function drawRobot(x, y, bodyHeight, neckHeight) {

  var radius = 45;
  var ny = y - bodyHeight - neckHeight - radius;

  // Cuello
  stroke(102);
  line(x +  2, y - bodyHeight, x +  2, ny);
  line(x + 12, y - bodyHeight, x + 12, ny);
  line(x + 22, y - bodyHeight, x + 22, ny);

  // Antenas
  line(x + 12, ny, x - 18, ny - 43);
  line(x + 12, ny, x + 42, ny - 99);
  line(x + 12, ny, x + 78, ny + 15);

  // Cuerpo
  noStroke(102);
  fill(102);
  ellipse(x, y - 33, 33, 33);
  fill(0);
  rect(x - 45, y - bodyHeight, 90, bodyHeight - 33);
  fill(102);
  rect(x - 45, y - bodyHeight + 17, 90, 6);

  // Cabeza
  fill(0);
  ellipse(x + 12, ny    , radius, radius);
  fill(255);
  ellipse(x + 24, ny - 6, 14, 14);
  fill(0);
  ellipse(x + 24, ny - 6, 3, 3);
  fill(153);
  ellipse(x     , ny -  8, 5, 5);
  ellipse(x + 30, ny - 26, 4, 4);
  ellipse(x + 41, ny +  6, 3, 3);
}
```
</section>

<section data-type="chapter" id="capitulo_10_objetos">

<h1>Cap&#xED;tulo 10. Objetos</h1>

<p>La programaci&#xF3;n orientada a objetos (OOP) es una manera diferente de pensar sobre tus programas. Los objetos son tambi&#xE9;n una manera de agrupar variables con funciones relacionadas. Como ya sabes c&#xF3;mo trabajar con variables y funciones, los objetos simplemente combinan lo que ya has aprendido en un paquete m&#xE1;s f&#xE1;cil de entender.</p>

<p>Los objetos son importantes, porque permiten dividir las ideas en bloques m&#xE1;s peque&#xF1;os. Esto se parece al mundo real donde, por ejemplo, los &#xF3;rganos est&#xE1;n hechos de tejido, el tejido est&#xE1; hecho de c&#xE9;lulas y as&#xED;. Similarmente, a medida que tu c&#xF3;digo se va volviendo m&#xE1;s complejo, tienes que pensar en t&#xE9;rminos de estructuras m&#xE1;s peque&#xF1;as que forman estructuras m&#xE1;s complicadas. Es m&#xE1;s f&#xE1;cil escribir y mantener pedazos de c&#xF3;digo m&#xE1;s peque&#xF1;os y f&#xE1;ciles de entender, que trabajan en conjunto con otros, que es escribir un gran trozo de c&#xF3;digo que hace todo al mismo tiempo.</p>

## Propiedades y m&#xE9;todos

<p>Un objeto es un conjunto de variables y funciones relacionadas. En el contexto de los objetos, una variable se llama propiedad (o variable de instancia) y una funci&#xF3;n es llamada m&#xE9;todo. Las propiedades y los m&#xE9;todos funcionan tal como las variables y las funciones vistas en los cap&#xED;tulos anteriores, pero usaremos estos nuevos t&#xE9;rminos para enfatizar que son parte de un objeto. Para decirlo de otra manera, un objeto combina datos relacionados (propiedades) con acciones y comportamientos relacionados (m&#xE9;todos). La idea es agrupar datos y m&#xE9;todos relacionados.</p>

<p>Por ejemplo, para hacer un modelo de una radio, piensa en los par&#xE1;metros que pueden ser ajustados y las acciones que pueden afectar estos par&#xE1;metros:</p>

Propiedades

volume, frequency, band(FM, AM), power (on, off)

M&#xE9;todos

setVolume, setFrequency, setBand

<p>Modelar un dispostivo mec&#xE1;nico simple es f&#xE1;cil comparado a modelar un organismo como una hormiga o una persona. No es posible reducir un organismo complejo a unas pocas propiedades y m&#xE9;todos, pero es posible modelarlo suficientemente bien como para crear una simulaci&#xF3;n interesante. El video juego The Sims es un claro ejemplo. Este juego consiste en administrar las actividades diarias de personas simuladas. Los personajes tienen la suficiente personalidad como para hacer un juego adictivo, pero no m&#xE1;s que eso. De hecho, ellos solo tienen cinco atributos de personalidad: ordenado, extrovertido, activo, juguet&#xF3;n y simp&#xE1;tico. Con el conocimiento de que es posible hacer un modelo altamente simplificado de organismos complejos, podr&#xED;amos empezar a programar una hormiga con unas pocas propiedades y m&#xE9;todos:</p>

Propiedades:

tipo(trabajador, soldado), peso, ancho

M&#xE9;todos:

caminar, picar, liberarFeromonas, comer

<p>Si hicieras una lista de las propiedades y m&#xE9;todos de una hormiga, podr&#xED;as escoger enfocarte en modelar diferentes aspectos de la hormiga. No existe una manera correcta de hacer un modelo, mientras lo hagas apropiado para el pr&#xF3;posito de las metas de tu programa.</p>

## Define un Constructor

<p>Para crear un objeto, empieza por definir una funci&#xF3;n constructor. Una funci&#xF3;n constructor es la especificaci&#xF3;n de un objeto. Usando una analog&#xED;a arquitect&#xF3;nica, una funci&#xF3;n constructor es como el plano de una casa, y un objeto es como la casa en s&#xED; misma. Cada casa construida con el mismo plano puede tener variaciones, y el plano es la &#xFA;nica especificaci&#xF3;n, no una estructura fija. Por ejemplo, una casa puede ser azul y otra roja, una casa puede tener una chimenea y la otra no. Tal como los objetos, el constructor define los tipos de datos y comportamientos, pero cada objeto (casa) hecho de la misma funci&#xF3;n constructor (plano) tiene variables (color, chimenea) que tienen distintos valores. Para usar un t&#xE9;rmino m&#xE1;s t&#xE9;cnico, cada objeto es una instancia y cada instancia tiene su propio conjunto de propiedades y m&#xE9;todos.</p><p>

</p><p>Antes de que escribas una funci&#xF3;n constructor, recomendamos un poco de planificaci&#xF3;n. Piensa en qu&#xE9; propiedades y m&#xE9;todos deber&#xED;an tener tus objetos. Haz una lluvia de ideas para imaginar todas las opciones posibles y luego prioriza y haz tu mejor conjetura sobre qu&#xE9; funcionar&#xE1;. Har&#xE1;s cambios durante el proceso de programaci&#xF3;n, pero es importante tener un buen comienzo.</p>

<p>Para nuestra primera funci&#xF3;n constructor, convertiremos el Ejemplo 8-9 de antes en el libro. Empezamos por hacer una lista de propiedades del ejemplo:</p>

```javascript
var x;
var y;
var diameter;
var speed;
```

<p>El siguiente paso es resolver qu&#xE9; m&#xE9;todos pueden ser &#xFA;tiles para el objeto. Revisando la funci&#xF3;n draw() del ejemplo que estamos adaptando, vemos dos componentes primarios. La posici&#xF3;n de la figura es actualizada y dibujada en la pantalla. Creemos dos m&#xE9;todos para nuestro objeto, uno para cada funci&#xF3;n:</p>

```javascript
function move();
function display();
```

<p>Ninguno de nuestros m&#xE9;todos retornan un valor. Una vez que hemos determinado las propiedades y m&#xE9;todos que el objeto deber&#xED;a tener, escribiremos nuestra funci&#xF3;n constructor para asignarlos a cada instancia del objeta que crearemos (Figura 10-1).</p>

<p>El c&#xF3;digo dentro la funci&#xF3;n constructor es corrido una vez cuando el objeto es creado. Para crear la funci&#xF3;n constructor, seguiremos tres pasos:</p>

1. Crear un bloque de funci&#xF3;n.

2. A&#xF1;adir las propiedades y asignarles valores.

3. A&#xF1;adir los m&#xE9;todos.

Primero, creamos un bloque de funci&#xF3;n para nuestro constructor:

```javascript
function JitterBug() {

}
```

<p>Observa que el nombre JitterBug empieza con may&#xFA;scula. Nombrar la funci&#xF3;n constructor con letra may&#xFA;scula no es requerida, pero es una convenci&#xF3;n (que recomendamos fuertemente) usada para denotar que es un constructor. (La palabra clave function, sin embargo, debe ser min&#xFA;scula porque es una regla del lenguaje de programaci&#xF3;n).</p>

<p>Segundo, a&#xF1;adimos las propiedades. Javascript tiene una palabra reservada especial, this, que puedes usar dentro la funci&#xF3;n constructor para referirse al objeto actual. Cuando declaras una propiedad de un objeto, dejamos fuera el s&#xED;mbolo var, y en vez de eso anteponemos el nombre de la variable con this. para indicar que estamos asignando una propiedad, una variable del objeto. Podemos declarar y asignar la propiedad speed de la siguiente manera:</p>

```javascript
function JitterBug() {
  this.speed = 0.5;
}
```

<p>Mientras estamos haciendo esto, tenemos que decidir qu&#xE9; propiedades tendr&#xE1;n sus valores pasados a trav&#xE9;s del constructor. Como regla general, los valores de las propiedades que quieran ser diferentes para cada instancia son pasados a trav&#xE9;s del constructor, y los otros valores de propiedades pueden ser definidos dentro del constructor, como lo es speed en este caso. Para el objeto JitterBug, hemos decidido que los valores de x, y y di&#xE1;metro ser&#xE1;n pasados. Cada uno de los valores pasados es asignado a una variable temporal que existe solo mientras el c&#xF3;digo es ejecutado. Para clarificar esto, hemos a&#xF1;adido el nombre temp a cada una de estas variables, pero pueden ser nombradas con cualquier nombre que prefieras. Ser&#xE1;n usadas solo para asignar los valores de las propiedades que son parte del objeto. As&#xED; que a&#xF1;adimos tempX, tempY y tempDiameter como par&#xE1;metros para la funci&#xF3;n, y las propiedades son declaradas y asignadas as&#xED;:</p>

```javascript
function JitterBug(tempX, tempY, tempDiameter) {
  this.x = tempX;
  this.y = tempY;
  this.diameter = tempDiameter;
  this.speed = 0.5;   // El mismo valor para cada instancia
}
```

<p>El &#xFA;ltimo paso es a&#xF1;adir los m&#xE9;todos. Esto es justo como escribir funciones, pero aqu&#xED; est&#xE1;n contenidas dentro de la funci&#xF3;n constructor, y la primera l&#xED;nea es escrita un poco diferente. Normalmente, una funci&#xF3;n para actualizar variables puede ser escrita as&#xED;:</p>

```javascript
function move() {
  x += random(-speed, speed);
  y += random(-speed, speed);
}
```

<p>Como queremos hacer esta funci&#xF3;n un m&#xE9;todo del objeto, nuevamente necesitamos usar la palabra reservada this. La funci&#xF3;n anterior puede ser convertida en un m&#xE9;todo as&#xED;:</p>

```javascript
this. move = function() {
  this.x += random(-this.speed, this.speed);
  this.y += random(-this.speed, this.speed);
};
```

<p>La primera l&#xED;nea se ve un poco extra&#xF1;a, pero la manera de interpretarla es &quot;crear una variable de instancia (propiedad) llamada move, y luego le asigna como su valor esta funci&#xF3;n&quot;. Luego, cada vez que nos referimos a las propiedades del objeto, podemos nuevamente usar this., tal como lo hacemos cuando est&#xE1;n inicialmente declaradas. Juntando todo en el constructor el resultado es este:</p>

```javascript
function JitterBug(tempX, tempY, tempDiameter) {
  this.x = tempX;
  this.y = tempY;
  this.diameter = tempDiameter;
  this.speed = 2.5;

  this.move = function() {
    this.x += random(-this.speed, this.speed);
    this.y += random(-this.speed, this.speed);
  };

  this.display = function() {
    ellipse(this.x, this.y, this.diameter, this.diameter);
  };
}
```

<p>Tambi&#xE9;n observa el espaciado en el c&#xF3;digo. Cada l&#xED;nea dentro del constructor est&#xE1; indentada unos pocos espacios para mostrar lo que est&#xE1; dentro del bloque. Dentro de estos m&#xE9;todos, el c&#xF3;digo est&#xE1; espaciado nuevamente para mostrar claramente la jerarqu&#xED;a.</p>

## Crea objetos

<p>Ahora que has definido una funci&#xF3;n constructor, para usarla en un programa debes crear un instancia de objeto con ese constructor. Hay dos pasos para crear un objeto:</p>

1. Declara la variable objeto.

2. Crea (inicializa) el objeto con la palabra clave new.

## Ejemplo 10-1: haz un objeto

<p>Para hacer tu primer objeto, empezaremos mostrando c&#xF3;mo esto funciona dentro un bosquejo de p5.js y luego continuaremos explicando cada parte en profundidad:</p>

```javascript
var bug;

function setup() {
  createCanvas(480, 120);
  background(204);
  // Crea un objeto y pasa los par&#xE1;metros
  bug = new JitterBug(width/2, height/2, 20);
}

function draw() {
  bug.move();
  bug.display();
}

// Copia aqu&#xED; el c&#xF3;digo del constructor de Jitterbug
```

<p>Declaramos variables de objeto en la misma manera que todas las otras variables - el objeto es declarado escribiendo la palabra reservada var seguida del nombre de la variable:</p>

 ```javascript
 var bug;
 ```

 <p>El segundo paso es inicializar el objeto con la palabra reservada new. Hace espacio en la memoria para el objeto con todas sus propiedades y m&#xE9;todos. El nombre del constructor es escrito a la derecha de la palabra reservada new, seguido de los par&#xE1;metros dentro del constructor, si es que tiene alguno:</p>

 ```javascript
 bug = new JitterBug(width/2, height/2, 20);
 ```

 <p>Los tres n&#xFA;meros dentro de los par&#xE9;ntesis son los par&#xE1;metros pasados dentro de la funci&#xF3;n constructor JitterBug. El n&#xFA;mero y orden de estos par&#xE1;metros deben corresponder con los del constructor.</p>

## Ejemplo 10-2: haz m&#xFA;ltiples objetos

<p>En el Ejemplo 10-1, vimos algo nuevo: el punto que es usado para acceder a los m&#xE9;todos del objeto dentro de draw(). El operador punto es usado para unir el nombre del objeto con sus propiedades y m&#xE9;todos. Es an&#xE1;logo a la manera en que usamos this. dentro de la funci&#xF3;n constructor, pero cuando nos referimos a esto fuera del constructor, this es reemplazado por el nombre de la variable.</p>

<p>Esto se torna m&#xE1;s claro en este ejemplo, donde dos objetos son hechos con el mismo constructor. La funci&#xF3;n jit.move() se refiere al m&#xE9;todo move() que pertenece al objeto nombrado jit, y bug.move() se refiere al m&#xE9;todo move() y pertenece al objeto llamado bug:</p>

```javascript
var jit;
var bug;

function setup() {
  createCanvas(480, 120);
  background(204);
  jit = new JitterBug(width * 0.33, height/2, 50);
  bug = new JitterBug(width * 0.55, height/2, 10);
}

function draw() {
  jit.move();
  jit.display();
  bug.move();
  bug.display();
}

// Copia aqu&#xED; el c&#xF3;digo del constructor de JitterBug
```

<p>Ahora que la funci&#xF3;n constructor existe como su propio m&#xF3;dulo de c&#xF3;digo, cualquier cambio modificar&#xE1; los objetos hechos con &#xE9;lla. Por ejemplo, podr&#xED;as a&#xF1;adir una propiedad al constructor JitterBug que controla el color, u otra que determina su tama&#xF1;o. Estos valores pueden ser pasados usados el constructor o usando m&#xE9;todos adicionales, como setColor() o setSize(). Y como es una unidad auto-contenida, tambi&#xE9;n puedes usar el constructor JitterBug en otro bosquejo.</p>

<p>Ahora es un buen momento para aprender sobre usar m&#xFA;ltiples archivos en Javascript. Esparcir tu c&#xF3;digo en m&#xE1;s de un archivo hace que el c&#xF3;digo m&#xE1;s largo sea m&#xE1;s f&#xE1;cil de editar y m&#xE1;s manejable en general. Un nuevo archivo es usualmente creado para cada constructor, lo que refuerza la modularidad de trabajar con objetos y hacer el c&#xF3;digo m&#xE1;s f&#xE1;cil de encontrar.</p>

<p>Crea un nuevo archivo en el mismo directorio que tu actual archivo sketch.js. Puedes nombrarlo como quieras, pero es una buena idea nombrarlo JitterBug.sjs por conceptos de organizaci&#xF3;n. Mueve la funci&#xF3;n constructor JitterBug a este nuevo archivo. Enlaza el archivo JitterBug.js en tu archivo HTML a&#xF1;adiendo una l&#xED;ena dentro de HEAD bajo la l&#xED;nea donde enlazas el archivo sketch.js:</p>

```html
<script type="text/javascript" src="sketch.js"></script>
<script type="text/javascript" src="JitterBug.js"></script>
```

## Robot 8: objetos

<p>Un objeto en software puede combinar m&#xE9;todos (funciones) y propiedades (variables) en una unidad. La funci&#xF3;n constructor Robot en este ejemplo define todos los objetos robot que ser&#xE1;n creados desde &#xE9;l. Cada objeto Robot tiene su propio conjunto de propiedades para almacenar una posic&#xF3;n y la ilustraci&#xF3;n que dibujar&#xE1; en la pantalla. Cada uno tiene m&#xE9;todos para actualizar la posici&#xF3;n y mostrar la ilustraci&#xF3;n.</p>

<p>Los par&#xE1;metros para bot1 y bot2 en setup() definen las coordenadas x e y y el archivo .svg que ser&#xE1; usado para dibujar el robot. Los par&#xE1;metros tempX y tempY son pasados al constructor y asignados a las propiedades xpos y ypos. El par&#xE1;metro imgPath es usado para cargar la ilustraci&#xF3;n relacionada. Los objetos (bot1 y bot2) dibujan en su propia ubicaci&#xF3;n con una ilustraci&#xF3;n difrente porque cada uno tienen valores distintos pasados a los objetos a trav&#xE9;s de sus constructores:</p>

```javascript
var img1;
var img2;

var bot1;
var bot2;

function preload() {
  img1 = loadImage(&quot;robot1.svg&quot;);
  img2 = loadImage(&quot;robot2.svg&quot;);
}

function setup() {
  createCanvas(720, 480);
  bot1 = new Robot(img1,  90, 80);
  bot2 = new Robot(img2, 440, 30);
}

function draw() {
  background(204);

  // Actualiza y muestra el primer robot
  bot1.update();
  bot2.display();

  // Actualiza y muestra el segundo robot
  bot2.update();
  bot2.display();
}

function Robot(img, tempX, tempY) {
  // Define los valores iniciales para las propiedades
  this.xpos = tempX;
  this.ypos = tempY;
  this.angle = random(0, TWO_PI);
  this.botImage = img;
  this.yoffset = 0.0;

  // Actualiza las propiedades
  this.update = function() {
    this.angle += 0.05;
    this.yoffset = sin(this.angle) * 20;
  }

  // Dibuja el robot en la pantallla
  this.display = function() {
    image(this.botImage, this.xpos, this.ypos + this.yoffset);
  }
}
```
</section>

<section data-type="chapter" id="capitulo_11_arreglos">

<h1>Cap&#xED;tulo 11. Arreglos</h1>

<p>Un arreglo es una lista de variables que comparten un nombre com&#xFA;n. Los arreglos son &#xFA;tiles porque hacen posible trabajar con m&#xE1;s variables sin crear un nombre nuevo para cada uno. Esto hace que el c&#xF3;digo sea m&#xE1;s corto, m&#xE1;s f&#xE1;cil de leer, y m&#xE1;s conveniente de actualizar.</p>

## De variables a arreglos

<p></p>Cuando un programa necesita mantener registro de una o dos cosas, no es necesario crear un arreglo. Sin embargo, cuando un programa posee muchos elementos (por ejemplo, un campo de estrellas en un juego sobre el espacio o m&#xFA;ltiples puntos de datos en una visualizaci&#xF3;n), los arreglos hacen que el c&#xF3;digo sea m&#xE1;s f&#xE1;cil de escribir.<p></p>

## Ejemplo 11-1: muchas variables

<p>Para entender lo que significa, revisa el Ejemplo 8-3. Este c&#xF3;digo funciona bien si estamos moviendo una sola figura, &#xBF;pero qu&#xE9; pasa si queremos tener dos? Necesitamos crear una nueva variable x y actualizarla dentro de draw():</p>

```javascript
var x1 = -20;
var x2 =  20;

function setup() {
  createCanvas(240, 120);
  noStroke();
}

function draw() {
  background(0);
  x1 += 0,5;
  x2 += 0.5;
  arc(x1, 30, 40, 40, 0.52, 5.76);
  arc(x2, 90, 40, 40, 0.52, 5.76);
}
```

## Ejemplo 11-2: demasiadas variables

<p>El c&#xF3;digo del ejemplo anterior es todav&#xED;a manejable, &#xBF;pero qu&#xE9; pasa si queremos tener cinco c&#xED;rculos? Necesitamos a&#xF1;adir tres otras variables a las dos que ya tenemos:</p>

```javascript
var x1 = -10;
var x2 =  10;
var x3 =  35;
var x4 =  18;
var x5 =  30;

function setup() {
  createCanvas(240, 120);
  noStroke();
}

function draw() {
  background(0);
  x1 += 0,5;
  x2 += 0.5;
  x3 += 0.5;
  x4 += 0.5;
  x5 += 0.5;
  arc(x1,  20, 20, 20, 0.52, 5.76);
  arc(x2,  40, 20, 20, 0.52, 5.76);
  arc(x3,  60, 20, 20, 0.52, 5.76);
  arc(x4,  80, 20, 20, 0.52, 5.76);
  arc(x5, 100, 20, 20, 0.52, 5.76);
}
```

<p>&#xA1;Este c&#xF3;digo est&#xE1; empezando a salirse de control!</p>

## Ejemplo 11-3: arreglos, no variables

<p>Imagina lo que pasar&#xED;a si quisieras tener 3.000 variables. Esto significar&#xED;a crear 3.000 variables individuale y luego actualizar cada una de ellas de forma separada. &#xBF;Podr&#xED;as mantener registro de esta cantidad de variables? &#xBF;Quisieras hacerlo? En vez de eso, usemos un arreglo:</p>

```javascript
var x = [];

function setup() {
  createCanvas(240, 120);
  noStroke();
  fill(255, 200);
  for (var i = 0; i &lt; 3000; i++) {
    x[i] = random(-1000, 200);
  }
}

function draw() {
  background(0);
  for (var i = 0; i &lt; x.length; i ++) {
    x[i] += 0.5;
    var y = i * 0.4;
    arc(x[i], y, 12, 12, 0.52, 5.76);
  }
}
```

<p>Durante el resto de este cap&#xED;tulo revisaremos los detalles que hacen que este ejemplo sea posible.</p>

## Construir un arreglo

<p>Cada item en el arreglo es llamado un elemento, y cada uno tiene un &#xED;ndice para se&#xF1;alar su posici&#xF3;n dentro del arreglo. Tal como las coordenadas en el lienzo, los valores de &#xED;ndice para un arreglo empiezan su cuenta desde 0. Por ejemplo, el primer elemento en el arreglo tiene un &#xED;ndice con valor 0, el segundo elemento del arreglo tiene un &#xED;ndice con valor 1, y as&#xED;. Si hay 20 valores en el arreglo, el valor del &#xED;ndice del &#xFA;ltimo elemento es 19. La Figura 11-1 muestra la estructura conceptual de un arreglo.</p>

<p>Usar arreglos es similar a trabajar con variables &#xFA;nicas, sigue los mismos patrones. Como ya sabes, puedes hacer una variable sola llamada x con este c&#xF3;digo:</p>

```javascript
var x;
```

<p>Para hacer un arreglo, basta con determinar que el valor de la variable sea un par de corchetes vac&#xED;os:</p>

```javascript
var x = [];
```

<p>Nota que no es necesario declarar por adelantado la longitud del arreglo, la longitud es determinada por el n&#xFA;mero de elementos que t&#xFA; pones en &#xE9;l.</p>

## Nota

<p>Un arreglo puede almacenar todos los diferentes tipos de datos (boolean, number, string, etc). Puedes mezclar y combinar diferentes tipos de datos en un mismo arreglo.</p>

<p>Antes de que nos adelantemos, desaceleremos y hablemos del trabajo con arreglos en mayor detalle. Hay dos pasos cuando se trabaja con arreglos:</p>

1. Declara el arreglo

2. Asigna valores a cada elemento.

<p>Cada paso puede pasar en una l&#xED;nea distinta, o se pueden combinar los dos pasos en uno. Cada uno de los dos siguientes ejemplos muestra una t&#xE9;cnica diferente para crear un arreglo llamado x que almacena dos n&#xFA;meros, 12 y 2. Toma mucha atenci&#xF3;n a lo que pasa antes de setup() y lo que pasa en setup().</p>

## Ejemplo 11-4: declara y asigna un arreglo

<p>Primero, declararemos un arreglo fuera de setup() y luego creamos y asignamos valores dentro. La sintaxis x[0] se refiere al primer elemento del arreglo y x[1] es el segundo:</p>

```javascript
var x = [];   // Declara el arreglo

function setup() {
  createCanvas(200, 200);
  x[0] = 12;  // Asigna el primer valor
  x[1] = 2;   // Asigna el segundo valor
}
```

## Ejemplo 11-5: asigna valores en un arreglo en una pasada

<p>Tambi&#xE9;n puedes asignar valores a un arreglo cuando es creado, si todo es parte de la misma declaraci&#xF3;n:</p>

```javascript
var x = [12, 2];   // Declara y asigna valores en el arreglo

function setup() {
  createCanvas(200, 200);
}
```

## Nota

<p>Evita crear arreglos dentro de draw(), porque crear un nuevo arreglo en cada cuadro desacelerar&#xE1; la tasa de cuadros.</p>

## Ejemplo 11-6: revisitando el primer ejemplo

<p>Como un ejemplo completo de c&#xF3;mo usar arreglos, hemos reescrito el Ejemplo 11-1 aqu&#xED;. A pesar de que no vemos todav&#xED;a todos los beneficios revelados en el Ejemplo 11-3, s&#xED; vemos algunos detalles importantes de c&#xF3;mo funcionan los arreglos:</p>

```javascript
var x = [-20, 20];

function setup() {
  createCanvas(240, 120);
  noStroke();
}

function draw() {
  background(0);
  x[0] += 0.5; // Incrementa el primer elemento
  x[1] += 0.5; // Incrementa el segundo elemento
  arc(x[0], 30, 40, 40, 0.52, 5.76);
  arc(x[1], 90, 40, 40, 0.52, 5.76);
}
```

## Repetici&#xF3;n y arreglos

<p>El for loop, introducido en &quot;Repetici&#xF3;n&quot;, har&#xE1; m&#xE1;s f&#xE1;cil trabajar con arreglos grandes mientras se mantiene el c&#xF3;digo conciso. La idea es escribir un loop para recorrer cada elemento del arreglo uno a uno. Para hacerlo, necesitar&#xE1;s saber el largo del arreglo. La propiedad length asocidada con cada arreglo almacena el n&#xFA;mero de elementos. Usamos el nombre del arreglo con el operador punto para accedera este valor. Por ejemplo:</p>

```javascript
var x = [12, 20];     // Declara y asigna valores al arreglo
print(x.length);      // Imprime 2 en la consola

var y = [&quot;cat&quot;, 10, false, 50];     // Declara y asigna valores al arreglo
print(y.length);      // Imprime 4 en la consola

var z = [];       // Declara un arreglo vac&#xED;o
print(z.length);  // Imprime 0 en la consola
z[0] = 20;        // Asigna un elemento al arreglo
print(z.length);  // Imprime 1 en la consola
z[1] = 4;         // Asigna un elemento al arreglo
print(z.length);  // Imprime 2 en la consola
```

## Ejemplo 11-7: llenando un arreglo con un for loop

<p>Un for loop puede ser usado para llenar un arreglo con valores, o para leer los valores. En este ejemplo, el arreglo es primero llenado con n&#xFA;meros aleatorios dentro de setup(), y luego esos n&#xFA;meros son usados para definir el valor del trazado dentro de draw(). Cada vez que el programa corre, un nuevo conjunto de valores aleatorios es puesto en el arreglo:</p>

```javascript
var gray = [];

function setup() {
  createCanvas(240, 120);
  for (var i = 0; i &lt; width; i++) {
    gray[i] = random(0, 255);
  }
}

function draw() {
  background(204);
  for (var i = 0; i &lt; gray.length; i++) {
    stroke(gray[i]);
    line(i, 0, i, height);
  }
}
```

<p>En setup(), insertamos tantos elementos como el ancho del lienzo. Esto es un n&#xFA;mero arbitrario, lo hemos elegido para que al dibujar una l&#xED;nea vertical por cada elemento, se llene el ancho del lienzo. Podr&#xED;as tratar de cambiar width a cualquier n&#xFA;mero. Una vez que los elementos son asignados al arreglo, somos capaces de iterar a trav&#xE9;s de ellos en draw() usando la propiedad length. No podemos iterar a trav&#xE9;s del arreglo en setup() porque antes de que cualquier elemento sea puesto dentro, el largo del arreglo gray es 0.</p>

## Ejemplo 11-8: seguir la trayectoria del rat&#xF3;n

<p>En este ejemplo, existen dos arreglos para almacenar la posici&#xF3;n del rat&#xF3;n - uno para la coordenada x y uno para la coordenada y. Estos arreglos graban la posici&#xF3;n del rat&#xF3;n durante los &#xFA;ltimos 60 cuadros. Con cada nuevo cuadro, los valores de las coordenadas x e y m&#xE1;s antiguos son removidos y reemplazados con el valor actual de mouseX y mouseY. Los nuevos valores son a&#xF1;adidos a la primera posici&#xF3;n del arreglo, pero antes de que esto pase, cada valor del arreglo es movido una posici&#xF3;n a la derecha (desde el &#xFA;ltimo hasta el primero) para hacer espacio para los nuevos n&#xFA;meros. (La Figura 11-2 es un diagrama que ilustra este proceso). Este ejemplo visualiza esta acci&#xF3;n. Adem&#xE1;s, en cada cuadro, las 60 coordenadas son usadas para dibujar una serie de elipses en la pantalla:</p>

```javascript
var num = 60;
var x = [];
var y = [];

function setup() {
  createCanvas(240, 120);
  noStroke();

  for (var i = 0; i &lt; num; i++) {
    x[i] = 0;
    y[i] = 0;
  }
}

function draw() {
  background(0);
  // Copia los valores del arreglo de atr&#xE1;s hacia adelante
  for (var i = num-1; i &gt; 0; i--) {
    x[i] = x[i - 1];
    y[i] = y[i - 1];
  }
  x[0] = mouseX;  // Define el primer elemento
  y[0] = mouseY;  // Define el primer elemento
  for (var i = 0; i &lt; num; i++) {
    fill(i * 4);
    ellipse(x[i], y[i], 40, 40);
  }
}
```

## Arreglos de objetos

<p>Los dos ejemplos cortos en esta secci&#xF3;n juntan cada gran concepto de programaci&#xF3;n en este libro: iteraci&#xF3;n, condicionales, funciones, objetos y arreglos. Hacer un arreglo de objetos es casi lo mismo que construir los arreglos que introducimos en las p&#xE1;ginas anteriores, pero existe una consideraci&#xF3;n inicial: porque cada elemento es un objeto, primero debe ser creado con la palabra reservada new (tal como cualquier otro objeto) antes de ser asignado a un arreglo. Con un objeto construido por el usuario como JitterBug (ver Cap&#xED;tulo 10), esto significa que new definir&#xE1; cada elemento antes de ser asignado al arreglo.</p>

## Ejemplo 11-9: administrando varios objetos

<p>Este ejemplo crea un arreglo de 33 objetos JitterBug y luego actualiza y muestra cada uno dentro de draw(). Para que este ejemplo funcione, necesitas a&#xF1;adir la funci&#xF3;n constructor JitterBug al c&#xF3;digo:</p>

```javascript
var bugs = [];

function setup() {
  createCanvas(240, 120);
  background(204);
  for (var i = 0; i &lt; 33, i++) {
    var x = random(width);
    var y = random(height);
    var r = i + 2;
    bugs[i] = new JitterBug(x, y, r);
  }
}

function draw() {
  for (var i = 0; i &lt; bugs.length; i++) {
    bugs[i].move();
    bugs[i].display();
  }
}

//Copia aqu&#xED; el c&#xF3;digo de la funci&#xF3;n constructor de Jitterbug
```

<p>El ejemplo final de arreglos carga una secuencia y almacena cada elemento dentro de un arreglo.</p>

## Ejemplo 11-10: secuencias de im&#xE1;genes

<p>Para correr este ejemplo, obt&#xE9;n las im&#xE1;genes desde media.zip tal como lo descrito en el Cap&#xED;tulo 7. Las im&#xE1;genes son nombradas secuencialmente (frame-0000.png, frame-0001.png, etc.), lo que hace posile crear el nombre de cada archivo dentro de un for loop, tal como lo vemos en la s&#xE9;ptima l&#xED;nea del programa:</p>

```javascript
var numFrames = 12;     // El n&#xFA;mero de cuadros
var images = [];        // Crear el arreglo
var currentFrame = 0;

function preload() {
  for (var i = 0; i &lt; numFrames; i++) {
    var imageName = &quot;frame-&quot; + nf(i, 4) + &quot;.png&quot;;
    images[i] = loadImage(imageName); //Carga cada imagen
  }
}

function setup() {
  createCanvas(240, 120);
  frameRate(24);
}

function draw() {
  image(images[currentFrame], 0, 0);
  currentFrame++;  // Siguiente cuadro
  if (currentFrame == images.length) {
    currentFrame = 0; // Retorna al primer cuadro
  }
}
```

<p>La funci&#xF3;n nf() define el formato de n&#xFA;meros de modo que nf(1, 4) retorna el string &quot;0001&quot; y nf(11, 4) retorna &quot;0011&quot;. Estos valores est&#xE1;n concatenados con el inicio del nombre del archivo (frame-) y el final (.png) para crear el nombre completo del archivo almacenado en una variable. Los archivos son cargados en un arreglo en la siguiente l&#xED;nea. Las im&#xE1;genes son mostradas en la pantalla una a la vez en draw(). Cuando la &#xFA;ltima imagen en el arreglo es mostrada, el programa vuelve al principio del arreglo y muestra las im&#xE1;genes en secuencia.</p>

## Robot 9: arreglos

<p>Los arreglos hacen m&#xE1;s f&#xE1;cil que un programa trabaje con muchos elementos. En este ejemplo, un arreglo de objetos Robot es declarado al principio. El arreglo es luego posicionado dentro de setup(), y cada objeto Robot es creado dentro del for loop. En draw(), otro for loop es usado para actualizar y mostrar cada elemento del arreglo bots.</p>

<p>El for loop y un arreglo hacen una combinaci&#xF3;n poderosa. Observa las diferencias sutiles entre el c&#xF3;digo para este ejemplo y Robot 8 (ver &quot;Robot 8: objetos&quot;) en contraste a los cambios extremos en el resultado visual. Una vez que el arreglo es creado y un for loop es incluido, es igualmente de f&#xE1;cil trabajar con 3 elementos que con 3,000.</p>

```javascript
var robotImage;
var bots = [];    // Declara un arreglo para almacenar objetos Robot

function preload() {
  robotImage = loadImage(&quot;robot1.svg&quot;);
}

function setup() {
  createCanvas(720, 480);

  var numRobots = 20;

  // Crea cada objeto
  for (var i = 0; i &lt; numRobots; i++) {
    // Crea una coordenada x aleatoria
    var x = random(-40, width - 40);
    // Asigna la coordenada y basada en el orden
    var y = map(i, 0, numRobots, -100, height - 200);
    bots[i] = new Robot(robotImage, x, y);
  }
}

function draw() {
  background(204);
  // Actualiza y muestra cada bot en el arreglo
  for (var i = 0; i &lt; bots.length; i++) {
    bots[i].update();
    bots[i].display();
  }
}

function Robot(img, tempX, tempY) {
  // Define los valores iniciales para las propiedades
  this.xpos = tempX;
  this.ypos = tempY;
  this.angle = random(0, TWO_PI);
  this.botImage = img;
  this.yoffset = 0.0;

  // Actualiza las propiedades
  this.update = function() {
    this.angle += 0.05;
    this.yoffset = sin(this.angle) * 20;
  }

  // Dibuja el robot en la pantalla
  this.display = function() {
    image(this.botImage, this.xpos, this.ypos + this.yoffset);
  }
}
```
</section>

<section data-type="chapter" id="capitulo_12_datos">

<h1>Cap&#xED;tulo 12. Datos</h1>

<p>La visualizaci&#xF3;n de datos es una de las &#xE1;reas m&#xE1;s activas en la intersecci&#xF3;n de la programaci&#xF3;n y las gr&#xE1;ficas y tambi&#xE9;n uno de los usos m&#xE1;s populares de p5.js. Este cap&#xED;tulo expando lo que se ha discutido sobre almacenamiento y carga de datos en el libro e introduce m&#xE1;s caracter&#xED;sticas relevantes a conjuntos de datos que pueden ser usados para visualizaci&#xF3;n.</p>

<p>Existe un gran rango de software que puede producir visualizaciones est&#xE1;ndar como gr&#xE1;ficos de barras y gr&#xE1;ficos de dispersi&#xF3;n. Sin embargo, escribir c&#xF3;digo desde cero para crear visualizaci&#xF3;n nos brinda mayor control sobre el resultado y anima a los usuarios a imaginar, explorar y crear representaciones de datos &#xFA;nicos. Para nosotros, este es el objetivo sobre aprender a programar y usar software como p5.js, y encontramos mucho m&#xE1;s interesante que estar limitado por m&#xE9;todos prefabricados o herramientas ya disponibles.</p>

## Resumen de datos

<p>Es un buen momento para rebobinar y discutir c&#xF3;mo los datos fueron introducidos a trav&#xE9;s de este libro. Una variable en un bosquejo de p5.js es usado para almacenar datos. Empezamos con variables primitivas. En este caso, la palabra primitiva significa un solo trozo de informaci&#xF3;n. Por ejemplo, una variable puede almacenar un n&#xFA;mero o un string.</p>

<p>Un arreglo es creado para almacenar una lista de elementos dentro de un &#xFA;nico nombre de variable.En el Ejemplo 11-7 se almacenan cientos de n&#xFA;meros a usarse para definir el trazado de las l&#xED;neas. Un objeto es una variable que almacena un conjunto de variables y funciones relacionadas.</p>

<p>Las variables y los objetos pueden ser definidos dentro del c&#xF3;digo, pero tambi&#xE9;n pueden ser cargados dentro de un archivo en el directorio del bosquejo. Los siguientes ejemplos en este cap&#xED;tulo lo demuestran.</p>

## Tablas

<p>Muchos conjuntos de datos son almacenados como filas y columnas (ver Figura 12-1), as&#xED; que p5.js incluye un objeto tabla para hacer m&#xE1;s f&#xE1;cil trabajar con ellos. Si haz trabajado con hojas de c&#xE1;lculo, tienes una ventaja al momento de trabajar con tablas al programar. p5.js puede leer una tabla desde un archivo, o crear una nueva directamente en c&#xF3;digo. Tambi&#xE9;n es posible leer y escribir cualquier fila y columna y modificar celdas individuales dentro de la tabla. En este cap&#xED;tulo, nos enfocaremos en trabajar con datos en tablas.</p>

<p>Los datos en tablas son usualmente almacenados en archivos de texto planos con las columnas usando comas o tabulaci&#xF3;n. Un archivo de valores separados por comas es abreviado como CSV y usa la extensi&#xF3;n de archivo .csv. Cuando se usa tabulaci&#xF3;n, la extensi&#xF3;n .tsv puede ser usada.</p>

<p>Para crear un archivo CSV o TSV, primero ponlo en el directorio del bosquejo tal como descrito en el comienzo del Cap&#xED;tulo 7, y luego usa la funci&#xF3;n loadTable() para obtener los datos y ponerlos en un objeto.</p>

## Nota

<p>Solo las primeras l&#xED;neas de cada conjunto de datos son mostradas en estos ejemplos. Si est&#xE1;s escribiendo manualmente el c&#xF3;digo, necesitar&#xE1;s el archivo .csv, .json o .tsv completo para replicar las visualizaciones mostradas en las figuras. Puedes encontrarlos en el archivo media.zip.</p>

<p>Los datos para el siguiente ejemplo son una versi&#xF3;n simplificada de las estad&#xED;sticas del jugador David Ortiz del equoipo Red Sox. De izquierda a derecha, est&#xE1; el a&#xF1;o, el n&#xFA;mero de home runs, runs batted in (RBI), y el promedio de bateo. Cuando el archivo es abierto en un editor de texto, las primeras cinco l&#xED;neas del c&#xF3;digo se ven as&#xED;:</p>

## Ejemplo 12-1: lee la tabla

<p>Para cargar los datos a p5.js, un objeto es creado usando el constructor p5.Table. El objeto en este ejemplo es llamado stats. La funci&#xF3;n loadTable() carga el archivo ortiz.csv desde el directorio de tu bosquejo. La funci&#xF3;n se encuentra dentro de preload() para asegurar que est&#xE9; completamente cargada antes de que los datos sean usados en setup().</p>

<p>En setup(), el for loop lee cada fila de la tabla en secuencia. Toma los datos desde la tabla y los graba en variables. El m&#xE9;todo getRowCount() es usado para contar el n&#xFA;mero de filas en cada archivo de datos. Como los datos sobre las estad&#xED;sticas de Ortiz van de 1997 a 2014, hay 18 filas que leer:</p>

```javascript
var stats;

function preload() {
  stats = loadTable(&quot;ortiz.csv&quot;);
}

function setup() {
  for (var i = 0; i &lt; stats.getRowCount(); i++) {
    // Recupera el valor de la fila i, columna 0 del archivo
    var year = stats.get(i, 0);
    // Recupera el valor de la fila i, columna 1 del archivo
    var homeRuns = stats.get(i, 1);
    var rbi = stats.get(i, 2);
    var average = stats.get(i, 3);
    print(year, homeRuns, rbi, average);
  }
}
```

<p>Dentro del for loop, el m&#xE9;todo get() es usado para tomar datos desde la tabla. Este m&#xE9;todo tiene dos par&#xE1;metros: el primero es la fila a leer y el segundo es la columna.</p>

## Ejemplo 12-2: dibuja la tabla

<p>El siguiente ejemplo expande el anterior. Crea un arreglo llamado homeRuns para grabar los datos despu&#xE9;s de ser cargados dentro de setup() y los datos del arreglo son usados dentro de draw(). El largo del arreglo es usado dos veces con el c&#xF3;digo homeRuns.length, para contar el n&#xFA;mero de iteraciones de un for loop. Es usado por primera vez para poner una marca vertical por cada item en el arreglo. Luego es usado para leer cada elemento del arreglo uno por uno y parar de leer del arreglo cuando termina. Despu&#xE9;s de que los datos son cargados dentro de preload() y le&#xED;dos desde el arreglo en setup(), el resto de este programa aplica lo que aprendimos en el Cap&#xED;tulo 11. La funci&#xF3;n getNum() es usada en vez de get() para asegurar que el valor es entendido como un n&#xFA;mero a usar en el gr&#xE1;fico.</p>

<p>Este ejemplo es la visualizaci&#xF3;n de una versi&#xF3;n simplificada de las estad&#xED;sticas de bateo entre 1997 y 2014 del jugador David Ortiz de los Boston Red Sox, dibujados con los datos de una tabla:</p>

```javascript
var stats;
var homeRuns = [];

function preload() {
  stats = loadTable(&quot;ortiz.csv&quot;);
}

function setup() {
  createCanvas(480, 120);
  var rowCount = stats.getRowCount();
  homeRuns = [];
  for (var i = 0; i &lt; rowCount; i++) {
    homeRuns[i] = stats.getNum(i, 1);
  }
}

function draw() {
  background(204);
  // Dibuja la matriz de fondo para los datos
  stroke(153);
  line(20, 100,  20,  20);
  line(20, 100, 460, 100);
  for (var i = 0; i &lt; homeRuns.length; i++) {
    var x = map(i, 0, homeRuns.length-1, 20, 460);
    line(x, 20, x, 100);
  }
  // Dibuja l&#xED;neas basadas en los datos sobre home run
  noFill(0);
  stroke(0);
  beginShape();
  for (var i = 0; i &lt; homeRuns.length; i++) {
    var x = map(i, 0, homeRuns.length - 1, 20, 460);
    var y = map(homeRuns[i], 0, 60, 100, 20);
    vertex(x, y);
  }
  endShape();
}
```

<p>Este ejemplo es tan minimalista que no es necesario guardar estos datos en un arreglo, pero la idea puede ser aplicada a ejemplos m&#xE1;s complejos que podr&#xED;as querer hacer en el futuro. Adicionalmente, puedes ver c&#xF3;mo este ejemplo puede ser aumentado con m&#xE1;s informaci&#xF3;n - por ejemplo, la informaci&#xF3;n en el eje vertical puede definir el n&#xFA;mero de home runs y en el horizontal definir el a&#xF1;o.</p>

## Ejemplo 12-3: 29.740 ciudades

<p>Para tener una mejor idea del potencial de trabajar con tablas de datos, el siguiente ejemplo usa un conjunto de datos m&#xE1;s grande e introduce una caracter&#xED;stica conveniente. Esta tabla de datos es diferente, porque la primera fila, la primera l&#xED;nea en el archivo, es un encabezado. El encabezado define una etiqueta para cada columna para clarificar el contexto. Estas son las primeras cinco l&#xED;neas de nuestro archivo de datos llamado cities.csv.</p>

```
zip, state, city, lat, lng
35004, AL, Acmar, 33.584132, -86.51557
35005, AL, Adamsville, 33.588437, -86.959727
35006, AL, Adger, 33.434277, -87.167455
35007, AL, Keystone, 33.236868, -86.812861
```

<p>El encabezado hace m&#xE1;s f&#xE1;cil leer el c&#xF3;digo - por ejemplo, la segunda l&#xED;nea del archivo establece que el c&#xF3;digo zip de Acmar, Alabama es 35004 y define la latitud de la ciudad como 33.584132 y la longitud como -86.51557. En total, el archivo tiene un largo de 29.741 l&#xED;neas y define la ubicaci&#xF3;n y los c&#xF3;digos zip de 29.740 ciudades en Estados Unidos. El siguiente ejemplo carga estos datos dentro la funci&#xF3;n preload() y luego los dibuja en la pantalla con un for loop dentro de draw(). La funci&#xF3;n setXY() convierte la latitud y la longitud de un archivo en una elipse en la pantalla:</p>

```javascript
var cities;

function preload() {
  cities = loadTable(&quot;cities.csv&quot;, &quot;header&quot;);
}

function setup() {
  createCanvas(480, 240);
  fill(255, 150);
  noStroke();
}

function draw() {
  background(0);
  var xoffset = map(mouseX, 0, width, -width * 3, -width);
  translate(xoffset, -600);
  scale(10);
  for (var i = 0; i &lt; cities.getRowCount(); i++) {
    var latitude = cities.getNum(i, &quot;lat&quot;);
    var longitude = cities.getNum(i, &quot;lng&quot;);
    setXY(latitude, longitude);
  }
}

function setXY(lat, lng) {
  var x = map(lng, -180, 180, 0,  width);
  var y = map(lat,   90, -90, 0, height);
  ellipse(x, y, 0.25, 0.25);
}
```

<p>Dentro de la funci&#xF3;n preload(), observa que hay un segundo par&#xE1;metro &quot;header&quot; a&#xF1;adido a la funci&#xF3;n loadTable(). Si esto no es hecho, entonces el c&#xF3;digo tratar&#xE1; la primera l&#xED;nea como datos y no como el t&#xED;tulo de cada columna. p5.Table tiene docenas de m&#xE9;todos para lograr a&#xF1;adir y remover columnas y filas, obtener una lista de entradas &#xFA;nicas en una columna, o ordenar la tabla. Una lista m&#xE1;s completa de m&#xE9;todos y ejemplos cortos son incluidos en la Referencia de p5.js.</p>


## JSON

<p>El formato JSON (JavaScript Object Notation) es otro sistema com&#xFA;n para almacenar datos. Tal como los formatos HTML y XML, los elementos tienen etiquetas asociadas a ellos. Por ejemplo, los datos de una pel&#xED;cula pueden incluir etiquetas para el t&#xED;tulo, director, a&#xF1;o de lanzamiento, calificaci&#xF3;n y m&#xE1;s. Estas etiquetas ser&#xE1;n emparejadas con datos de la siguiente manera:</p>

```JSON
&quot;title&quot;: &quot;Alphaville&quot;
&quot;director&quot;: &quot;Jean-Luc Godard&quot;
&quot;year&quot;: 1964
&quot;rating&quot;: 9.1
```

<p>Para funcionar como un archivo JOSN, necesida un poco de puntuaci&#xF3;n para separar los elementos. Se usan comas entre cada par de datos y llaves para encapsularlo. Los datos definidos dentro de las llaves son un objeto JSON. Con estos cambios nuestro archivo de datos JSON con formato v&#xE1;lido luce as&#xED;:</p>

```JSON
{
  &quot;title&quot;: &quot;Alphaville&quot;,
  &quot;director&quot;: &quot;Jean-Luc Godard&quot;,
  &quot;year&quot;: 1964,
  &quot;rating&quot;: 9.1
}
```

<p>Existe otro detalle interesante en este corto ejemplo JSON relacionado a los tipos de datos: te dar&#xE1;s cuenta que los datos de t&#xED;tulo y director est&#xE1;n encerrados en comillas para demarcarlos como datos de tipo string, mientras que el a&#xF1;o y la calificaci&#xF3;n no tienen comillas para definirlos como n&#xFA;meros. Esta distinci&#xF3;n se hace importante despu&#xE9;s de cargar los datos a un bosquejo.</p>

<p>Para a&#xF1;adir otra pel&#xED;cula a la lista, se usa un par de corchetes en el comienzo y el final del archivo JSON para significar que los datos son un arreglo de objetos JSON. Cada objeto es separado por una coma. Poniendo todo esto en pr&#xE1;ctica, luce as&#xED;:</p>

```JSON
[
  {
    &quot;title&quot;: &quot;Alphaville&quot;,
    &quot;director&quot;: &quot;Jean-Luc Godard&quot;,
    &quot;year&quot;: 1965,
    &quot;rating&quot;: 9.1
  },
  {
    &quot;title&quot;: &quot;Pierrot le Fou&quot;,
    &quot;director&quot;: &quot;Jean-Luc Godard&quot;,
    &quot;year&quot;: 1965,
    &quot;rating&quot;: 7.3
  }
]
```

<p>Este patr&#xF3;n puede ser repetido para incluir muchas pel&#xED;culas. En este punto, es interesante comparar esta notaci&#xF3;n JSON a la representaci&#xF3;n de tabla correspondiente a los mismos datos. Como un archivo CSV, los datos hubieran lucido as&#xED;:</p>

title, director, year, rating
Alphaville, Jean-Luc Godard, 1965, 9.1
Pierrot le Fou, Jean-Luc Godard, 1965, 7.3

<p>Observa que la notaci&#xF3;n CSV usa menos caracteres, lo que puede ser importante al momento de trabajar con conjuntos enormes de datos. Por otro lado, la versi&#xF3;n JSON es usualmente m&#xE1;s f&#xE1;cil de leer porque cada trozo de informaci&#xF3;n est&#xE1; etiquetado.</p>

<p>Ahora que se han introducido las nociones b&#xE1;sicos de JSON y su relaci&#xF3;n a tablas, revisemos el c&#xF3;digo necesario para leer un archivo JSON en un bosquejo de p5.js.</p>

## Ejemplo 12-4: leer un archivo JSON

<p>Este bosquejo carga el archivo JSON visto al principio de esta secci&#xF3;n, el archivo que incluye solo los datos de la pel&#xED;cula Alpaville:</p>

```javascript
var film;

function preload() {
  film = loadJSON(&quot;film.json&quot;);
}

function setup() {
  var title = film.title;
  var dir = film.director;
  var year = film.year;
  var rating = film.rating;
  print(title + &quot; by &quot; + dir + &quot;, &quot; + year + &quot;. Rating: &quot; + rating);
}
```

<p>Los datos del archivo son cargados a la variable. Los valores individuales pueden ser accesados usando el operador punto, de forma similar a como accedemos a las propiedades dentro de un objeto.</p>

## Ejemplo 12-5: visualiza datos desde un archivo JSON

<p>Tambi&#xE9;n podemos trabajar con un archivo JSON que contiene m&#xE1;s de una pel&#xED;cula. Aqu&#xED;, el archivo de datos comenzado en el ejemplo previo ha sido actualizado para incluir todas las pel&#xED;culas del director entre 1960 y 1966. El nombre de cada pel&#xED;cula es posicionado en orden en la pantalla seg&#xFA;n el a&#xF1;o de lanzamiento y es asignado un valor en la escala de grises seg&#xFA;n su calificaci&#xF3;n</p>.

<p>Existen varias diferencias entre este ejemplo y el Ejemplo 12-4. La m&#xE1;s importante es la manera en que el archivo JSON es cargado en los objetos FIlm. El archivo JSON es precargado dentro de preload(), poblando la variable filmData con un arreglo que tiene la misma estructura que los datos en el archivo. En setup(), un for loop es usado para iterar a trav&#xE9;s del arreglo de la informaci&#xF3;n de las pel&#xED;culas y crear un objeto basado en cada elemento en el arreglo, usando el constructor Film deinido aqu&#xED;. El constructor accede a porciones de la informaci&#xF3;n y los asigna a propiedades dentro de cada objeto. El constructor Film tambi&#xE9;n define un m&#xE9;todo para mostrar el nombre de la pel&#xED;cula:</p>

```javascript
var films = [];
var filmData;

function preload() {
  filmData = loadJSON(&quot;films.json&quot;);
}

function setup() {
  createCanvas(480, 120);
  for (var i = 0; i &lt; filmData.length; i++) {
    var o = filmData[i];
    films[i] = new Film(o);
  }
  noStroke();
}

function draw() {
  background(0);
  for (var i = 0; i &lt; films.length; i++) {
    var x = i * 32 + 32;
    films[i].display(x, 105);
  }
}

function Film(f) {
  this.title = f.title;
  this.director = f.director;
  this.year = f.year;
  this.rating = f.rating;

  this.display = function(x,y) {
    var ratingGray = map(this.rating, 6.5, 81, 102, 255);
    push();
    translate(x, y);
    rotate(QUARTER_PI);
    fill(ratingGray);
    text(this.title, 0, 0);
    pop();
  }
}
```

<p>Este ejemplo es crudo en su visualizaci&#xF3;n de datos sobre pel&#xED;culas, Muestra c&#xF3;mo cargar los datos y c&#xF3;mo dibujar bas&#xE1;ndose en esos valores de los datos, pero es tu desaf&#xED;o encontrar el formato que acent&#xFA;e lo que encuentras interesante sobre los datos. Por ejemplo, &#xBF;es m&#xE1;s interesante mostrar el n&#xFA;mero de pel&#xED;culas que hizo Godard cada a&#xF1;o?, &#xBF;es m&#xE1;s interesante comprar y contrastar estos datos con las pel&#xED;culas de otro director?, &#xBF;ser&#xED;a m&#xE1;s f&#xE1;cil de leer con una fuente, tama&#xF1;o del bosquejo o raz&#xF3;n de aspecto distintos?. Las habilidades introducidas en los cap&#xED;tulos anteriores de este libro pueden ser aplicadas para llevar este bosquejo al siguiente paso de refinamiento.</p>

## Datos de redes y APIs

<p>El acceso p&#xFA;blico a cantidades gigantes de datos recolectados por gobiernos, corporaciones, organizaciones e individuos est&#xE1; cambiando nuestra cultura, desde la manera en que socializamos hasta c&#xF3;mo pensamos osbre ideas intangibles como la privacidad. Estos datos son muy frecuentemente accesados a trav&#xE9;s de estructuras de software lllamadas APIs.</p>

<p>El acr&#xF3;nimo API es misterioso y su signifciad - interfaz de programaci&#xF3;n de aplicaciones - no es mucho m&#xE1;s clara. Sin embargo, las APIs son esenciales para trabajar con datos y no son necesariamente dif&#xED;ciles de comprender. Esencialmente, son requerimientos de datos hechos a un servicio. Cuando los conjuntos de datos son enormes, no es pr&#xE1;ctico ni deseable copiar la totalidad de los datos. Una API le permite a un programador pedir solo el goteo de datos que es relevante de este oc&#xE9;ano masivo.</p>

<p>El concepto puede ser ilustrado de manera m&#xE1;s clara con un ejemplo hipot&#xE9;tico. Asumamos que existe una organizaci&#xF3;n que mantiene una base de datos de rangos de temperatura para cada ciudad dentro de un pa&#xED;s. La API para este conjunto de datos le permite a un programador pedir las temperaturas m&#xE1;xima y m&#xED;nimas de cualquier ciudad durante el mes de octubre del a&#xF1;o 1972. Para requerir estos datos, la petici&#xF3;n debe ser hecha mediante una espec&#xED;fica l&#xED;nea o l&#xED;neas de c&#xF3;digo, en el formato requerido por el servicio de datos.</p>

<p>Algunas APIs son completamente p&#xFA;blicas, pero muchas requieren autenticaci&#xF3;n, que corresponde t&#xED;picamente a una identidad (ID) de usuario o llave para que el servicio de datos pueda mantener registro de sus usuarios. La mayor parte de las APIs tiene reglas sobre cu&#xE1;ntos y cu&#xE1;n frecuentemente se pueden hacer peticiones. Por ejemplo, podr&#xED;a ser posible hacer solo 1.000 requerimientos al mes, o no m&#xE1;s de una petici&#xF3;n por segundo.</p>

<p>p5.js puede solictar datos en Internet cuando el computador est&#xE1; corriendo el programa en l&#xED;nea. Los archivos CSV, TSV, JSON y XML correspondientes pueden ser cargados usando la funci&#xF3;n correspondiente de cargado usando la URL como par&#xE1;metro. Por ejemplo, el clima actual en Cincinnati est&#xE1; disponible en formato JSON en esta URL: http://api.openweathermap.org/data/2.5/find?q=Cincinnati&amp;units=imperial.</p>

<p>Lee la URL detenidamente para decodificarla:</p>

1. Pide datos al subdominio api del sitio openweathermap.org.

2. Especifica una ciudad a buscar (q es abreviaci&#xF3;n de query, b&#xFA;squeda, lo que frecuentemente es usado en URLs para especificar b&#xFA;squedas).

3. Tambi&#xE9;n indica que los datos deben ser retornados en formato imperial, lo que significa que la temperatura estar&#xE1; en Fahrenheit. Reemplazando imperial con metric se obtendr&#xE1; la temperatura en grados Celsius.

<p>Revisar estos datos de OpenWeatherMap es un ejemplo m&#xE1;s real&#xED;stico de trabajar con datos encontrados que los conjuntos de datos simplificados anteriores. Al momento de escribir, el archivo que retornaba la URL era el siguiente:</p>

<p>Este archivo es mucho m&#xE1;s f&#xE1;cil de leer cuando es retornado con saltos de l&#xED;nea, y el objeto JSON y las estructuras del arreglo est&#xE1;n definidas con llaves y corchetes:</p>

```JSON
{
  &quot;message&quot;: &quot;accurate&quot;,
  &quot;count&quot;: 1,
  &quot;cod&quot;: &quot;200&quot;,
  &quot;list&quot;: [{
    &quot;clouds&quot;: {&quot;all&quot;: 80},
    &quot;dt&quot;: 1423501526,
    &quot;coord&quot;: {
      &quot;lon&quot;: -84.456886,
      &quot;lat&quot;:  39.161999
    },
    &quot;id&quot;: 4508722,
    &quot;wind&quot;: {
      &quot;speed&quot;: 9.48,
      &quot;deg&quot;: 354.002
    },
    &quot;sys&quot;: {&quot;country&quot;: &quot;US&quot;},
    &quot;name&quot;: &quot;Cincinati&quot;,
    &quot;weather&quot;: [{
      &quot;id&quot;: 803,
      &quot;icon&quot;: &quot;04d&quot;,
      &quot;description&quot;: &quot;broken clouds&quot;,
      &quot;main&quot;: &quot;Clouds&quot;
      }],
      &quot;main&quot;: {
        &quot;humidity&quot;: 77,
        &quot;pressure&quot;: 999.98,
        &quot;temp_max&quot;: 34.16,
        &quot;sea_level&quot;: 1028.34,
        &quot;temp_min&quot;: 34.16,
        &quot;temp&quot;: 34.16,
        &quot;grnd_level&quot;: 999.98
      }
    }]
}
```

<p>Observa que los corchetes en las secciones de &quot;list&quot; y &quot;weather&quot;, indican una secci&#xF3;n de objetos JSON. Aunque el arreglo en este ejemplo solo contiene un solo &#xED;tem, en otros casos, la API podr&#xED;a retornar diversos d&#xED;as o varaciones de m&#xFA;ltiples estaciones metereol&#xF3;igicas.</p>

## Ejemplo 12-6: procesando la informaci&#xF3;n del tiempo

<p>El primer paso en trabajar con estos datos es estudiarlos y luego escribir un poco de c&#xF3;digo para extraer los datos deseados. En este caso, estamos curiosos sobre la temperatura actual. Podemos ver que nuestro dato de temperatura es de 34.16. Est&#xE1; marcado como temp y est&#xE1; dentro del objeto main y est&#xE1; adentro del arreglo list. Una funci&#xF3;n llamada getTemp() fue escrito espec&#xED;ficamente para que este c&#xF3;digo funcione con el formato de organizaci&#xF3;n de archivos JSON.</p>

```javascript
var weatherData;

function preload() {
  var temp = getTemp(weatherData);
  print(temp);
}

function setup() {
  var temp = getTemp(weatherData);
  print(temp);
}

function getTemp(data) {
  var list = data.list;
  var item = list[0];
  var main = item.main;
  var t = main.temp;
  return t;
}
```

<p>Los datos del archivo JSON son cargados en preload() y son pasados a la funci&#xF3;n getTemp() dentro de setup(). Luego, por el formato del archivo JSON, una serie de variables es usada para llegar m&#xE1;s y m&#xE1;s profundo en la estructura de los datos para finalmente llegar al n&#xFA;mero que deseamos. Este n&#xFA;mero es almacenado en la variable temperature y luego retornada por la funci&#xF3;n para ser asignada a la variable temp en setup() donde es impresa en la consola.</p>

## Ejemplo 12-7: concatenando m&#xE9;todos

<p>La secuencia de variables JSON creada en sucesi&#xF3;n en el ejemplo anterior puede ser aproximada de forma distinta usando accesores. Este ejemplo funciona como el Ejemplo 12-6, pero los m&#xE9;todos son conectadas con el operador punto, en vez de ser calculados uno a la vez y asignados a variables entre medio:</p>

```javascript
var weatherData;

function preload() {
  weatherData = loadJSON(&quot;cincinnati.json&quot;);
}

function setup() {
  var temp = getTemp(weatherData);
  print(temp);
}

function getTemp(data) {
  return data.list[0].main.temp;
}
```

<p>Adem&#xE1;s nota c&#xF3;mo la temperatura final es retornada por la funci&#xF3;n getTemp(). En el Ejemplo 12-6, una variable es creada para almacenar el valor, luego ese valor es retornado. Aqu&#xED;, el valor de la temperatura es retornado directamente, sin una variable intermedia.</p>

<p>Este ejemplo puede ser modificado para acceder a m&#xE1;s datos de la organizaci&#xF3;n y para construir un bosquejo que muestre los datos en la pantalla en vez de solo escribirlos en la consola. Tambi&#xE9;n puedes modificarlo para que lea datos de otra API - te encontrar&#xE1;s con que los datos retornados por muchas APIs comparten un formato similar.</p>


## Robot 10: datos

<p>El ejemplo final de robot en este libro es diferente del resto porque tiene dos partes. La primera parte genera un archivo usando valores aleatorios y for loops y la segunda parte lee ese archivo de datos para dibujar un ej&#xE9;rcito de robots en la pantalla.</p>

<p>El primer bosquejo usa dos nuevos elementos de c&#xF3;digo, la clase PrintWriter y la funci&#xF3;n createWriter(). Usadas en conjunto, crean y abren un archivo en el directorio del bosquejo para almacenar los datos generados por el bosquejo. En este ejemplo, el objeto creado con PrintWriter es llamado output y el archivo es llamado botArmy.tsv. En los loops, los datos son escritos al archivo corriendo el m&#xE9;todo println() en el objeto de salida. Aqu&#xED;, los valores aleatorios son usados para definir cu&#xE1;l de las tres im&#xE1;genes del robot ser&#xE1;n dibujadas para cada coordenada. Para que el archivo se cree correctamente, el m&#xE9;todo close() debe ser ejecutado antes de que el programa se detenga. El c&#xF3;digo que dibuja una elipse es un adelanto visual para revelar la posici&#xF3;n de la coordenada en la pantalla, pero noten que la elipse no est&#xE1; grabada en el archivo:</p>

```javascript
var output;

function setup() {
  createCanvas(720, 480);
  // Crea el nuevo archivo
  output = createWriter(&quot;botArmy.tsv&quot;);
  // Escribe una l&#xED;nea de encabezado con los t&#xED;tulos de las columnas
  output.println(&quot;type\tx\ty&quot;);
  for (var y = 0; y <= height;="" y="" +="60);" {="" for="" (var="" x="0;" <="width;" var="" robottype="int(random(1," 4));="" output.println(robottype="" "\t"="" y);="" ellipse(x,="" y,="" 12,="" 12);="" }="" output.close();="" cierra="" el="" archivo="" ```="" <p="">Despu&#xE9;s que el programa es corrido, el archivo botArmy.tsv ser&#xE1; creado en el directorio del bosquejo. &#xC1;brelo para revisar c&#xF3;mo se escriben los datos. Las primeras l&#xED;neas de c&#xF3;digo de este archivo ser&#xE1;n similares a esto:<p></p>

<p>La primera columna es esencial para definir qu&#xE9; imagen de robot se va a usar, la segunda columna es la coordenada x, la tercera coluna es la coordenada y. El siguiente bosquejo carga nuestro archivo botArmy.tsv y usa los datos para estos prop&#xF3;sitos:</p>

```javascript
 var robots;
 var bot1;
 var bot2;
 var bot3;

 function preload() {
   bot1 = loadImage(&quot;robot1.png&quot;);
   bot2 = loadImage(&quot;robot2.png&quot;);
   bot3 = loadImage(&quot;robot3.png&quot;);
   robots = loadTable(&quot;botArmy.tsv&quot;, &quot;header&quot;);
 }

 function setup() {
   createCanvas(720, 480);
   imageMode(CENTER);
   for (var i = 0; i &lt; robots.getRowCount(); i++) {
     var bot = robots.getNum(i, &quot;type&quot;);
     var x = robots.getNum(i, &quot;x&quot;);
     var y = robots.getNum(i, &quot;y&quot;);
     var sc = 0.15;
     if (bot == 1) {
       image(bot1, x, y, bot1.width*sc, bot1.height*sc);
     } else if (bot == 2) {
       image(bot2, x, y, bot2.width*sc, bot2.height*sc);
     } else {
       image(bot3, x, y, bot3.width*sc, bot3.height*sc);
     }
   }
 }
```

<p>Una variaci&#xF3;n m&#xE1;s concisa (y flexible) de este bosquejo usa arreglos como un enfoque m&#xE1;s avanzado:</p>

```javascript
var numRobotTypes = 3;
var images = [];
var scaling = 0.15;
var botArmy;

function preload() {
  for (var i = 0; i &lt; numRobotTypes; i++) {
    images[i] = loadImage(&quot;robot&quot; + (i+1) + &quot;.png&quot;);
  }
  botArmy = loadTable(&quot;botArmy.tsv&quot;, &quot;header&quot;);
}

function setup() {
  createCanvas(720, 480);
  imageMode(CENTER);
  for (var i = 0; i &lt; botArmy.getRowCount(); i++) {
    var robotType = botArmy.getNum(i, &quot;type&quot;);
    var x = botArmy.getNum(i, &quot;x&quot;);
    var y = botarmy.getNum(i, &quot;y&quot;);

    var bot = images[robotType - 1];
    image(bot, x, y, width*scaling, bot.height * scaling);
  }
}
```
</=></section>

<section data-type="chapter" id="capitulo_13_extension">

<h1> Cap&#xED;tulo 13. Extensi&#xF3;n </h1>

<p>Este libro se enfoca en usar p5.js para hacer gr&#xE1;ficas interactivas, porque eso es lo principal que p5.js hace. Sin embargo, este software puede realizar mucho m&#xE1;s que esto, y est&#xE1; siendo extendido m&#xE1;s all&#xE1; todo el tiempo.</p>

<p>Una librer&#xED;a de p5.js es un conjunto de c&#xF3;digo que extiende el software m&#xE1;s all&#xE1; de sus funciones principales. Las librer&#xED;as han sido una parte importante del crecimiento de este proyecto, porque le permite a los desarrolladores a&#xF1;adir nuevas funciones r&#xE1;pidamente. Como projectos autocontenidos y m&#xE1;s peque&#xF1;os, las librer&#xED;as son m&#xE1;s f&#xE1;ciles de manejar que si sus caracter&#xED;sticas estuvieran integradas al software principal.</p>

<p>El archivo .zip completo de p5.js incluye las librer&#xED;as p5.dom y p5.sound. Tambi&#xE9;n puedes bajar otras librer&#xED;as desde http://p5js.org/libraries/. Para usar una de estas librer&#xED;as, primero aseg&#xFA;rate de que est&#xE1; dentro del directorio que contiene tus archivos HTML y JavaScript. En segundo lugar, a&#xF1;ade una l&#xED;nea de c&#xF3;digo a tu archivo HTML para indicar que la librer&#xED;a ser&#xE1; usada en el bosquejo actual. Esta l&#xED;nea deber&#xED;a verse as&#xED;:</p>

```html
<script language="javascript" type="text/javascript" src="relative/path/to/p5.libraryName.js"> </script>
```

<p>relative/path deber&#xED;a ser reemplazado por la ubicaci&#xF3;n requerida para ubicar el archivo de librer&#xED;a relativo al archivo HTML. Si necesitas subir un directorio, inserta &quot;..&quot;. Por ejemplo, si est&#xE1;s trabajando con el ejemplo vac&#xED;o de la librer&#xED;a de p5.sound.js de la descarga completa de p5.js complet, la l&#xED;nea ser ver&#xED;a as&#xED;:</p>

```html
<script language="javascript" type="text/javascript" src="../p5.sound.js"> </script>
```

## p5.sound

<p> La librer&#xED;a p5.sound tiene la habilidad de reproducir, analizar y generar (sintetizar) sonido. A continuaci&#xF3;n se presentan una s pocas funciones clave; consultar la Referencia de p5.js para muchos m&#xE1;s objetos que pueden ser creados y funciones que pueden ser llamadas: http://p5js.org/reference/#/libtstird/p5.sound.</p>

 <p>Como las im&#xE1;genes, archivos JSON, y los archivos de texto introducidos en el Cap&#xED;tulo 7, un archivo de audio es otro tipo de medio para aumentar un bosquejo de p5.js. Sigue las instrucciones en ese cap&#xED;tulo para aprender c&#xF3;mo cargar un archivo de sonido en el directorio de un bosquejo. La librer&#xED;a p5.sound puede cargar un gran rango de formatos de archivos de audio incluyendo WAV, AIFF y MP3. Una vez que un archivo es cargado, puede ser reproducido, pausado y repetido as&#xED; mismo como distorsionado por un grupo de funciones de efecto.</p>

 ## Ejemplo 13-1: reproduce un sample

 <p>El uso m&#xE1;s com&#xFA;n de la librer&#xED;a p5.sound es para tocar un sonido cuando un evento ocurre en la pantalla o como m&#xFA;sica de fondo. Este ejemplo se basa en el Ejemplo 8-5 para reproducir un sonido cuando la figura llega a los bordes de la pantalla. El archivo blip.wav es incluido en la carpeta media que puede ser descargada siguiendo las instrucciones del cap&#xED;tulo 7. As&#xED; como con otros medios, una variable para almacenar un objeto p5.SoundFile (que es lo que la funci&#xF3;n loadSound() retorna) es definida en la parte superior del bosquejo, es cargada con preload() y despu&#xE9;s de eso, puede ser usada en cualquier parte del prorgrama:</p><p>

 ```javascript
 var blip;

 var radius = 120;
 var x = 0;
 var speed = 1.0;
 var direction = 1;

 function preload() {
   blip = loadSound(&quot;blip.wav&quot;);
 }

 function setup() {
   createCanvas(440, 440);
   ellipseMode(RADIUS);
   x = width/2; // Parte en el centro
 }

 function draw() {
   background(0);
   x += speed * direction;
   if ((x &gt; width - radius) || (x &lt; radius)) {
     direction = - direction; // Invierte la direcci&#xF3;n
     bip,play();
   }
   if (direction == 1) {
     arc(x, 220, radius, radius, 0.52, 5.76);
   } else {
     arc(x, 220, radius, radius, 3.67, 8.9);
   }
 }
 ```

</p><p>El sonido es gatillado cada vez que el m&#xE9;todo play() es ejecutado. Este ejemplo funciona bien porque el sonido solo est&#xE1; siendo reproducido cuando el valor de la variable x est&#xE1; en las orillas de la pantalla. Si el sonido fuera tocado en cada ejecuci&#xF3;n de draw(), el sonido se reiniciar&#xED;a 60 veces por segundo y no tendr&#xED;a tiempo de terminar de sonar. El resultado ser&#xED;a un sonido distorsionando r&#xE1;pidamente. Para tocar un sample m&#xE1;s largo mientras un programa corre, llama a los m&#xE9;todos play(), loop() para que suenen dentro de setup() as&#xED; que el sonido as&#xED; se gatilla una sola vez.</p>

## Nota

<p>El objeto p5.soundFile tiene muchos m&#xE9;todos para controlar c&#xF3;mo un sonido es reproducido. Lo m&#xE1;s esenciales son play() para tocar el sample una vez, loop() para tocarlo desde el principio hasta el fin una y otra vez, stop() para parar la reproducci&#xF3;n y jump() para moverse a un momento espec&#xED;fico dentro del archivo.</p>

## Ejemplo 13-2: escucha un micr&#xF3;fono

<p>Adem&#xE1;s de reproduicr sonidos, p5.js puede escuchar. Si tu computador tiene un micr&#xF3;fono incorporado o conectado, la librer&#xED;a p5.sound puede leer audio en vivo a trav&#xE9;s de &#xE9;l. Una vez que los datos del micr&#xF3;fono est&#xE1;n conectados al software, los puedes analizar, modificar o reproducir:</p>

```javascript
var mic;
var amp;

var scale = 1.0;

function setup() {
  createCanvas(440, 440);
  background(0);
  // Crea una entrada de audio y empieza a escuchar
  mic = new p5.AudioIn();
  mic.start();
  // Crea un nuevo analizador de amplitud y con&#xE9;ctalo a la entrada
  amp = new p5.Amplitude();
  amp.setInput(mic);
}

function draw() {
  // Dibuja un fondo que se vaya a negro
  noStroke(0);
  fill(0, 10);
  rect(0, 0, width, height);
  // El m&#xE9;todo getLevel() retorna valores entre 0 y 1
  // as&#xED; que map() es usado para convertir los valores a n&#xFA;meros mayores
  scale = map(amp.getLevel(), 0, 1.0, 10, width);
  // Dibuja el c&#xED;rculo basado en el volumen
  fill(255);
  ellipse(width/2, height/2, scale, scale);
}
```

<p>Hay dos partes que est&#xE1;n tomando la amplitud (volumen) del micr&#xF3;fono a&#xF1;adido. El objeto p5.AudioIn es usado para obtener la se&#xF1;al del micr&#xF3;fono y el objeto p5.Amplitude es usado para medir la se&#xF1;al.</p>

<p>Las variables para almacenar ambos objetos est&#xE1; definidas en la parte de arriba del c&#xF3;digo y creadas dentro de setup(). Despu&#xE9;s del objeto p5.Amplitude() (en este programa es llamado amp), el objeto p5.AudioIn, nombrado mic, es conectado al objeto amp con el m&#xE9;todo setInput(). Despu&#xE9;s de eso, el m&#xE9;todo getLevel() del objeto amp puede ser ejecutado en cualquier momento para leer la amplitud del micr&#xF3;fono dentro del programa. En este ejemplo, eso es hecho cada vez en draw() y ese valor es usado para definir el tama&#xF1;o del c&#xED;rculo.</p>

<p>Adem&#xE1;s de tocar un sonido y analizar un sonido como fue demostrado en los &#xFA;ltimos dos ejemplos, p5.js puede sintetizar sonido directamente. Los fundamentos de la s&#xED;ntesis de sonido son formas de onda, entre las que se incluyen las ondas sinusoidales, triangulares y cuadradas. Una onda sinusoidal suena agradable, una onda cuadrada es m&#xE1;s dura y una onda triangular est&#xE1; entre medio. Cada onda tiene un n&#xFA;mero de propiedades. La frecuencia, medida en Hertz, determina la altura, cu&#xE1;n grave o agudo es el tono. La amplitud de la onda determina el volumen.</p>

## Ejemplo 13-3: crear una onda sinusoidales

<p>En el siguiente ejemplo, el valor de mouseX determina la frecuencia de la onda sinusoidal. Mientras el rat&#xF3;n se mueve a la izquierda y derecha, la frecuencia audible y la correspondiente visualizaci&#xF3;n de la onda aumenta y decae:</p>

```javascript
var sine;

var freq = 440;

function setup() {
  createCanvas(440, 440);

  // Crea e inicia el oscilador sinusoidal
  sine = new p5.SinOsc();
  sine.start;
}

function draw() {
  background(0);
  // Mapea el valor de mouseX entre 20 Hz y 440 Hz para la frecuencia
  var hertz = map(mouseX, 0, width, 20.0, 440.0);
  sine.freq(hertz);
  // Dibuja una onda para visualizar la frecuencia del sonido
  stroke(204);
  for (var x = 0; x &lt; width; x++) {
    var angle = map(x, 0, width, 0, TWO_PI * hertz);
    var sinValue = sin(angle) * 120;
    line(x, 0, x, height/2 + sinValue);
  }
}
```

<p>El objeto sine, creado con el constructor de p5.SinOsc, es definido al principio del c&#xF3;digo y luego creado dentro de setup(). El m&#xE9;todo start() hace que la onda empieza a generar sonido. Dentro de draw(), el m&#xE9;todo freq() define continuamente la frecuencia de la onda, bas&#xE1;ndose en la posici&#xF3;n izquierda y derecha del rat&#xF3;n.</p>

## p5.dom

<p>La librer&#xED;a p5.dom tiene la habilidad de crear e interactuar con elementos HTML fuera del lienzo gr&#xE1;fico. La sigla DOM viene de Document Object Model, que se refiere a un conjunto de m&#xE9;todos para interactuar program&#xE1;ticamente con la p&#xE1;gina HTML. Los siguientes ejemplos presentan unas pocas funciones clave. Revisa la Referencia de p5.js para muchos m&#xE1;s elementos que pueden ser creados y funciones que pueden ser llamadas: http://p5js.org/reference/#/libraries/p5.dom.</p>

<p>Tal como createCanvas() crea un lienzo gr&#xE1;fico en la p&#xE1;gina, p5.dom incluye un n&#xFA;mero de otros m&#xE9;todos create para a&#xF1;adir otros elementos HTML a la p&#xE1;gina. Ejemplos incluyen video, links URL, cuadros de entrada y barras deslizadoras.</p>

## Ejemplo 3-14: accede a la webcam

<p>createCapture() accede a la webcam en tu computador y crea un elemento HTML que muestra su audio y video. Una vez que el elemento de captura es creado, puede ser dibujado en el lienzo y ser manipulado:</p>

```javascript
var capture;

function setup() {
  createCanvas(480, 120);
  capture = createCapture();
  capture.hide();
}

function draw() {
  var aspectRatio = capture.height/capture.width;
  var h = width * aspectRatio;
  image(capture, 0, 0, width, h);
  filter(INVERT);
}
```

<p>El objeto de capture est&#xE1; definido en la parte superior del c&#xF3;digo y luego es creado dentro de setup(). createCapture() de hecho adjunta un nuevo elemento a la p&#xE1;gina, pero como queremos dibujarlo en el lienzo, el m&#xE9;todo hide() es usado para esconder el objeto de captura. Revisa lo que pasa cuando descomentas esta l&#xED;nea de c&#xF3;digo.</p>

&lt;<p></p>p&gt;Deber&#xED;as ver dos copias del video, una invertida y una normal.<p></p>

<p>Los datos del objeto de captura son dibujados en el lienzo en la funci&#xF3;n draw() e invertidos usando el m&#xE9;todo filter().</p>

## Ejemplo 13-5: crea una barra deslizadora

<p>La funci&#xF3;n createSlider() crea una barra deslizadora que puede ser usada para manipular aspectos del bosquejo. Acepta tres argumentos - el valor m&#xED;nimo, el valor m&#xE1;ximo y el valor inicial:</p>

```javascript
var slider;

function setup() {
  createCanvas(480, 120);
  slider = createSlider(0, 255, 100);
  slider.position(20, 20);
}

function draw() {
  var gray = slider.value();
  background(gray);
}
```

<p>El objeto barra deslizadora es definido en la parte superior del c&#xF3;digo y luego creado dentro de setup(). Por defecto, el elemento ser&#xE1; adjuntado a la p&#xE1;gina, justo despu&#xE9;s del elemento m&#xE1;s recientemente creado en la p&#xE1;gina. El m&#xE9;todo position() permite darle una posici&#xF3;n relativa a la esquina superior izquierda. El m&#xE9;todo value() retorna el valor actual de la barra deslizadora, el cual est&#xE1; siendo usado para definir el color del fondo del lienzo en draw().</p>

## Ejemplo 13-6: crea un recuadro de entrada

<p>La funci&#xF3;n createInput() a&#xF1;ade un recuardo que puede ser usado para darle entrada de texto a tu programa. createButton() a&#xF1;ade un bot&#xF3;n que puede gatillar cualquier funci&#xF3;n que escojas. En este caso, el bot&#xF3;n es usado para entregar el texto dentro del recuadro de entrada al programa:</p>

```javascript
var input;
var button;

function setup() {
  createCanvas(480, 120);
  input = createInput();
  input.position(20, 30);
  button = createButton(&quot;submit&quot;);
  button.position(160, 30);
  button.mousePressed(drawName);

  background(100);
  noStroke();
  text(&quot;Enter your name. &quot;, 20, 20);
}

function drawName() {
  background(100);
  textSize(30);
  var name = input.value();
  for (var i = 0; i &lt; 30; i++) {
    text(name, random(width), random(height));
  }
}
```

<p>Los objetos entrada y bot&#xF3;n son definidos en la parte superior del c&#xF3;digo y creados dentro de setup(). createButton() aceptoa un argumento, la etiqueta a ser mostrada en el bot&#xF3;n. El m&#xE9;todo mousePressed() es usado para asignar una funci&#xF3;n a ejecutar cuando el bot&#xF3;n es presionado. Dentro de drawName(), los contenidos del recuadro de entrada son le&#xED;dos usando el m&#xE9;todo value(), y usados para llenar el fondo con el texto.</p>

</section>

  </body>
</html>
